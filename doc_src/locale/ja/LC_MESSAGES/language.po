# SOME DESCRIPTIVE TITLE.
# Copyright (C) fish-shell developers
# This file is distributed under the same license as the fish-shell package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2026.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: fish-shell 4.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-27 14:11+0900\n"
"PO-Revision-Date: 2026-02-27 15:07+0900\n"
"Last-Translator: t4k44 <95964+t4k44@users.noreply.github.com>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../doc_src/language.rst:2
msgid "The fish language"
msgstr "fish言語"

#: ../../doc_src/language.rst:4
msgid "This document is a comprehensive overview of fish's scripting language."
msgstr "この文書はfishのスクリプト言語の包括的な概要です。"

#: ../../doc_src/language.rst:6
msgid "For interactive features see :doc:`Interactive use <interactive>`."
msgstr "インタラクティブ機能については、 :doc:`Interactive use <interactive>` を参照してください。"

#: ../../doc_src/language.rst:11
msgid "Syntax overview"
msgstr "構文の概要"

#: ../../doc_src/language.rst:13
msgid ""
"Shells like fish are used by giving them commands. A command is executed "
"by writing the name of the command followed by any arguments. For "
"example::"
msgstr "fishのようなシェルはコマンドを与えることで使用されます。コマンドは、コマンド名の後に引数を続けて記述することで実行されます。例えば::"

#: ../../doc_src/language.rst:17
msgid ""
":doc:`echo <cmds/echo>` command writes its arguments to the screen. In "
"this example the output is ``hello world``."
msgstr ":doc:`echo <cmds/echo>` コマンドは引数を画面に出力します。この例では出力は ``hello world`` です。"

#: ../../doc_src/language.rst:19
msgid ""
"Everything in fish is done with commands. There are commands for "
"repeating other commands, commands for assigning variables, commands for "
"treating a group of commands as a single command, etc. All of these "
"commands follow the same basic syntax."
msgstr "fishではすべてコマンドで実行されます。他のコマンドを繰り返すコマンド、変数を代入するコマンド、複数のコマンドを1つのコマンドとして扱うコマンドなどがあります。これらのコマンドはすべて同じ基本構文に従います。"

#: ../../doc_src/language.rst:21
msgid ""
"Every program on your computer can be used as a command in fish. If the "
"program file is located in one of the :envvar:`PATH` directories, you can"
" just type the name of the program to use it. Otherwise the whole "
"filename, including the directory (like "
"``/home/me/code/checkers/checkers`` or ``../checkers``) is required."
msgstr ""
"コンピュータ上のすべてのプログラムは、fishのコマンドとして使用できます。プログラムファイルが :envvar:`PATH` "
"ディレクトリのいずれかにある場合は、プログラム名を入力するだけで使用できます。そうでない場合は、ディレクトリを含むファイル名全体(``/home/me/code/checkers/checkers``"
" や ``../checkers`` など)が必要です。"

#: ../../doc_src/language.rst:23
msgid "Here is a list of some useful commands:"
msgstr "ここにいくつかの便利なコマンドのリストがあります:"

#: ../../doc_src/language.rst:25
msgid ":doc:`cd <cmds/cd>`: Change the current directory"
msgstr ":doc:`cd <cmds/cd>`: 現在のディレクトリを変更する"

#: ../../doc_src/language.rst:26
msgid "``ls``: List files and directories"
msgstr "``ls``: ファイルとディレクトリの一覧を表示する"

#: ../../doc_src/language.rst:27
msgid ""
"``man``: Display a manual page - try ``man ls`` to get help on your "
"\"ls\" command, or ``man mv`` to get information about \"mv\"."
msgstr ""
"``man``: マニュアルページを表示します。 ``man ls`` で「ls」コマンドのヘルプを表示するか、 ``man mv`` "
"で「mv」に関する情報を表示します。"

#: ../../doc_src/language.rst:28
msgid "``mv``: Move (rename) files"
msgstr "``mv``: ファイルを移動(名前変更)する"

#: ../../doc_src/language.rst:29
msgid "``cp``: Copy files"
msgstr "``cp``: ファイルをコピーする"

#: ../../doc_src/language.rst:30
msgid ""
":doc:`open <cmds/open>`: Open files with the default application "
"associated with each filetype"
msgstr ":doc:`open <cmds/open>`: 各ファイルタイプに関連付けられたデフォルトのアプリケーションでファイルを開く"

#: ../../doc_src/language.rst:31
msgid "``less``: Display the contents of files"
msgstr "``less``: ファイルの内容を表示する"

#: ../../doc_src/language.rst:33
msgid ""
"Commands and arguments are separated by the space character ``' '``. "
"Every command ends with either a newline (by pressing the return key) or "
"a semicolon ``;``. Multiple commands can be written on the same line by "
"separating them with semicolons."
msgstr ""
"コマンドと引数はスペース文字 `` `` で区切られます。すべてのコマンドは、改行(リターンキーを押す)またはセミコロン ``;`` "
"で終わります。セミコロンで区切ることで、同じ行に複数のコマンドを記述できます。"

#: ../../doc_src/language.rst:35
msgid ""
"A switch is a very common special type of argument. Switches almost "
"always start with one or more hyphens ``-`` and alter the way a command "
"operates. For example, the ``ls`` command usually lists the names of all "
"files and directories in the current working directory. By using the "
"``-l`` switch, the behavior of ``ls`` is changed to not only display the "
"filename, but also the size, permissions, owner, and modification time of"
" each file."
msgstr ""
"スイッチは非常に一般的な特殊引数です。スイッチはほとんどの場合、1つ以上のハイフン ``-`` で始まり、コマンドの動作を変更します。例えば、 "
"``ls`` コマンドは通常、現在の作業ディレクトリにあるすべてのファイルとディレクトリの名前を一覧表示します。 ``-l`` "
"スイッチを使用すると、 ``ls`` の動作が変更され、ファイル名だけでなく、各ファイルのサイズ、権限、所有者、変更時刻も表示されます。"

#: ../../doc_src/language.rst:37
msgid ""
"Switches differ between commands and are usually documented on a "
"command's manual page. There are some switches, however, that are common "
"to most commands. For example, ``--help`` will usually display a help "
"text, ``--version`` will usually display the command version, and ``-i`` "
"will often turn on interactive prompting before taking action. Try ``man "
"your-command-here`` to get information on your command's switches."
msgstr ""
"スイッチはコマンドごとに異なり、通常はコマンドのマニュアルページに記載されています。ただし、ほとんどのコマンドに共通するスイッチもいくつかあります。たとえば、"
" ``--help`` は通常ヘルプテキストを表示し、 ``--version`` は通常コマンドのバージョンを表示し、 ``-i`` "
"はアクションを実行する前に対話型プロンプトをオンにすることがよくあります。コマンドのスイッチに関する情報を取得するには、 ``man your-"
"command-here`` を試してください。"

#: ../../doc_src/language.rst:39
msgid ""
"So the basic idea of fish is the same as with other unix shells: It gets "
"a commandline, runs :ref:`expansions <expand>`, and the result is then "
"run as a command."
msgstr ""
"fishの基本的な考え方は他のUnixシェルと同じです。コマンドラインを取得し、 :ref:`展開(expansions) <expand>` "
"を実行し、その結果をコマンドとして実行します。"

#: ../../doc_src/language.rst:42
msgid "Terminology"
msgstr "用語"

#: ../../doc_src/language.rst:44
msgid ""
"Here we define some of the terms used on this page and throughout the "
"rest of the fish documentation:"
msgstr "ここではこのページとfishに関するドキュメント全体で使用されている用語の一部を定義します。"

#: ../../doc_src/language.rst:46
msgid ""
"**Argument**: A parameter given to a command. In ``echo foo``, the "
"\"foo\" is an argument."
msgstr "**引数**: コマンドに与えられるパラメータ。 ``echo foo`` では、「foo」が引数となる。"

#: ../../doc_src/language.rst:48
msgid ""
"**Builtin**: A command that is implemented by the shell. Builtins are so "
"closely tied to the operation of the shell that it is impossible to "
"implement them as external commands. In ``echo foo``, the \"echo\" is a "
"builtin."
msgstr ""
"**組み込みコマンド**: "
"シェルによって実装されるコマンド。組み込みコマンドはシェルの動作と密接に結びついているため、外部コマンドとして実装することはできません。 "
"``echo foo`` では、「echo」は組み込みコマンドです。"

#: ../../doc_src/language.rst:50
msgid ""
"**Command**: A program that the shell can run, or more specifically an "
"external program that the shell runs in another process. External "
"commands are provided on your system, as executable files. In ``echo "
"foo`` the \"echo\" is a builtin command, in ``command echo foo`` the "
"\"echo\" is an external command, provided by a file like /bin/echo."
msgstr ""
"**コマンド**: "
"シェルが実行できるプログラム、より正確にはシェルが別のプロセスで実行する外部プログラム。外部コマンドは実行ファイルとしてシステムに提供されます。 "
"``echo foo`` の「echo」は組み込みコマンドであり、 ``command echo foo`` の「echo」は /bin/echo"
" のようなファイルによって提供される外部コマンドです。"

#: ../../doc_src/language.rst:52
msgid ""
"**Function**: A block of commands that can be called as if they were a "
"single command. By using functions, it is possible to string together "
"multiple simple commands into one more advanced command."
msgstr ""
"**関数**: "
"単一のコマンドのように呼び出せるコマンドのブロック。関数を使用することで、複数の単純なコマンドを1つの高度なコマンドにまとめることができます。"

#: ../../doc_src/language.rst:54
msgid "**Job**: A running pipeline or command."
msgstr "**ジョブ**: 実行中のパイプラインまたはコマンド"

#: ../../doc_src/language.rst:56
msgid ""
"**Pipeline**: A set of commands strung together so that the output of one"
" command is the input of the next command. ``echo foo | grep foo`` is a "
"pipeline."
msgstr ""
"**パイプライン**: 1つのコマンドの出力が次のコマンドの入力になるように連結されたコマンドのセット。 ``echo foo | grep "
"foo`` はパイプラインです。"

#: ../../doc_src/language.rst:58
msgid ""
"**Redirection**: An operation that changes one of the input or output "
"streams associated with a job."
msgstr "**リダイレクト**: ジョブに関連付けられた入力ストリームまたは出力ストリームのいずれかを変更する操作"

#: ../../doc_src/language.rst:60
msgid ""
"**Switch** or **Option**: A special kind of argument that alters the "
"behavior of a command. A switch almost always begins with one or two "
"hyphens. In ``echo -n foo`` the \"-n\" is an option."
msgstr ""
"**スイッチ**、**オプション**: コマンドの動作を変更する特殊な引数。スイッチはほとんどの場合、1つまたは2つのハイフンで始まります。 "
"``echo -n foo`` では「-n」はオプションです。"

#: ../../doc_src/language.rst:65
msgid "Quotes"
msgstr "クォート"

#: ../../doc_src/language.rst:67
msgid ""
"Sometimes you want to give a command an argument that contains characters"
" special to fish, like spaces or ``$`` or ``*``. To do that, you can use "
"quotes::"
msgstr "スペースや ``$`` 、 ``*`` など、fish特有の文字を含む引数をコマンドに与えたい場合があります。その場合は引用符を使用します::"

#: ../../doc_src/language.rst:71
msgid ""
"to remove a file called ``my file.txt`` instead of trying to remove two "
"files, ``my`` and ``file.txt``."
msgstr ""
"``my`` と ``file.txt`` という2つのファイルを削除しようとする代わりに、 ``my file.txt`` "
"というファイルを削除します。"

#: ../../doc_src/language.rst:73
msgid ""
"Fish understands two kinds of quotes: Single (``'``) and double (``\"``),"
" and both work slightly differently."
msgstr "Fishは2種類の引用符(``'``)と二重引用符(``\"``)を理解しますが、動作が少し異なります。"

#: ../../doc_src/language.rst:75
msgid ""
"Between single quotes, fish performs no expansions. Between double "
"quotes, fish only performs :ref:`variable expansion <expand-variable>` "
"and :ref:`command substitution <expand-command-substitution>` in the "
"``$(command)``. No other kind of expansion (including :ref:`brace "
"expansion <expand-brace>` or parameter expansion) is performed, and "
"escape sequences (for example, ``\\n``) are ignored. Within quotes, "
"whitespace is not used to separate arguments, allowing quoted arguments "
"to contain spaces."
msgstr ""
"一重引用符で囲まれた部分では、fishは展開を行いません。二重引用符で囲まれた部分では、fishは :ref:`変数展開 <expand-"
"variable>` と ``$(command)`` 内の :ref:`コマンド置換 <expand-command-"
"substitution>` のみを行います。その他の展開(:ref:`括弧展開 <expand-brace>` "
"やパラメータ展開を含む)は行わず、エスケープシーケンス(例： "
"``\\n``)は無視されます。引用符内では、引数の区切りに空白は使用されないため、引用符で囲まれた引数にはスペースを含めることができます。"

#: ../../doc_src/language.rst:77
msgid ""
"The only meaningful escape sequences in single quotes are ``\\'``, which "
"escapes a single quote and ``\\\\``, which escapes the backslash symbol. "
"The only meaningful escapes in double quotes are ``\\\"``, which escapes "
"a double quote, ``\\$``, which escapes a dollar character, ``\\`` "
"followed by a newline, which deletes the backslash and the newline, and "
"``\\\\``, which escapes the backslash symbol."
msgstr ""
"一重引用符内で有効なエスケープシーケンスは、一重引用符をエスケープする ``\\'`` と、バックスラッシュ記号をエスケープする ``\\\\``"
" のみです。二重引用符内で有効なエスケープシーケンスは、二重引用符をエスケープする ``\\\"`` 、ドル記号をエスケープする ``\\$`` "
"、バックスラッシュと改行を削除する ``\\`` の後に続く改行、およびバックスラッシュ記号をエスケープする ``\\\\`` のみです。"

#: ../../doc_src/language.rst:79
msgid "Single quotes have no special meaning within double quotes and vice versa."
msgstr "一重引用符は二重引用符内では特別な意味を持ちません。逆もまた同様です。"

#: ../../doc_src/language.rst:81
msgid "More examples::"
msgstr "その他の例::"

#: ../../doc_src/language.rst:85
msgid ""
"searches for lines ending in ``enabled)`` in ``foo.txt`` (the ``$`` is "
"special to ``grep``: it matches the end of the line)."
msgstr ""
"``foo.txt`` で ``enabled)`` で終わる行を検索します(``$`` は ``grep`` "
"にとって特別なもので、行末と一致します)"

#: ../../doc_src/language.rst:91
msgid ""
"installs all packages with a name starting with \"postgres-\", instead of"
" looking through the current directory for files named \"postgres-"
"something\"."
msgstr "現在のディレクトリで「postgres-」から始まるファイルを探す代わりに、「postgres-」で始まる名前を持つすべてのパッケージをインストールします。"

#: ../../doc_src/language.rst:96
msgid "Escaping Characters"
msgstr "文字のエスケープ"

#: ../../doc_src/language.rst:98
msgid ""
"Some characters cannot be written directly on the command line. For these"
" characters, so-called escape sequences are provided. These are:"
msgstr "一部の文字はコマンドラインに直接記述できません。これらの文字には、いわゆるエスケープシーケンスが用意されています。これらは:"

#: ../../doc_src/language.rst:100
msgid "``\\a`` represents the alert character."
msgstr "``\\a`` 警告文字"

#: ../../doc_src/language.rst:101
msgid "``\\e`` represents the escape character."
msgstr "``\\e`` エスケープ文字"

#: ../../doc_src/language.rst:102
msgid "``\\f`` represents the form feed character."
msgstr "``\\f`` フィード文字"

#: ../../doc_src/language.rst:103
msgid "``\\n`` represents a newline character."
msgstr "``\\n`` 改行文字"

#: ../../doc_src/language.rst:104
msgid "``\\r`` represents the carriage return character."
msgstr "``\\r`` 復帰文字"

#: ../../doc_src/language.rst:105
msgid "``\\t`` represents the tab character."
msgstr "``\\t`` タブ文字"

#: ../../doc_src/language.rst:106
msgid "``\\v`` represents the vertical tab character."
msgstr "``\\`` 垂直タブ文字"

#: ../../doc_src/language.rst:107
msgid ""
"``\\xHH`` or ``\\XHH``, where ``HH`` is a hexadecimal number, represents "
"a byte of data with the specified value. For example, ``\\x9`` is the tab"
" character. If you are using a multibyte encoding, this can be used to "
"enter invalid strings. Typically fish is run with the ASCII or UTF-8 "
"encoding, so anything up to ``\\X7f`` is an ASCII character."
msgstr ""
"``\\xHH`` または ``\\XHH`` (``HH`` は16進数)は、指定された値を持つ1バイトのデータを表します。例えば、 "
"``\\x9`` "
"はタブ文字です。マルチバイトエンコーディングを使用している場合、これは無効な文字列を入力するために使用できます。通常、fishはASCIIまたはUTF-8エンコードで実行されるため、"
" ``\\X7f`` まではASCII文字となります。"

#: ../../doc_src/language.rst:108
msgid ""
"``\\ooo``, where ``ooo`` is an octal number, represents the ASCII "
"character with the specified value. For example, ``\\011`` is the tab "
"character. The highest allowed value is ``\\177``."
msgstr ""
"``\\ooo`` (``ooo`` は8進数)は、指定された値を持つASCII文字を表します。例えば、 ``\\011`` "
"はタブ文字です。許容される最大値は ``\\177`` です。"

#: ../../doc_src/language.rst:109
msgid ""
"``\\uXXXX``, where ``XXXX`` is a hexadecimal number, represents the "
"16-bit Unicode character with the specified value. For example, ``\\u9`` "
"is the tab character."
msgstr ""
"``\\uXXXX`` (``XXXX`` は16進数)は、指定された値を持つ16ビットUnicode文字を表します。例えば、 ``\\u9`` "
"はタブ文字です。"

#: ../../doc_src/language.rst:110
msgid ""
"``\\UXXXXXXXX``, where ``XXXXXXXX`` is a hexadecimal number, represents "
"the 32-bit Unicode character with the specified value. For example, "
"``\\U9`` is the tab character. The highest allowed value is \\U10FFFF."
msgstr ""
"``\\UXXXXXXXX`` (``XXXXXXXX`` は16進数)は、指定された値を持つ32ビットUnicode文字を表します。例えば、 "
"``\\U9`` はタブ文字です。許容される最大値は ``\\U10FFFF`` です。"

#: ../../doc_src/language.rst:111
msgid ""
"``\\cX``, where ``X`` is a letter of the alphabet, represents the control"
" sequence generated by pressing the control key and the specified letter."
" For example, ``\\ci`` is the tab character"
msgstr ""
"``\\cX`` (``X`` "
"はアルファベットの文字)は、コントロールキーと指定された文字を押すことで生成される制御シーケンスを表します。例えば、 ``\\ci`` "
"はタブ文字です。"

#: ../../doc_src/language.rst:113
msgid ""
"Some characters have special meaning to the shell. For example, an "
"apostrophe ``'`` disables expansion (see :ref:`Quotes<quotes>`). To tell "
"the shell to treat these characters literally, escape them with a "
"backslash. For example, the command::"
msgstr ""
"一部の文字はシェルにとって特別な意味を持ちます。例えば、アポストロフィ ' は展開を無効にします( :ref:`クォート <quotes>` "
"参照)。シェルにこれらの文字を文字通りに扱うように指示するには、バックスラッシュでエスケープします。例えば、以下のコマンドは::"

#: ../../doc_src/language.rst:117
msgid "outputs ``'hello world'`` (including the apostrophes), while the command::"
msgstr "``'hello world'`` (アポストロフィを含む)を出力しますが、次のコマンド::"

#: ../../doc_src/language.rst:121
msgid ""
"outputs ``hello world`` (without the apostrophes). In the former case the"
" shell treats the apostrophes as literal ``'`` characters, while in the "
"latter case it treats them as special expansion modifiers."
msgstr ""
"``hello world`` (アポストロフィなし)を出力します。前者の場合、シェルはアポストロフィを文字通りの ``'`` "
"文字として扱いますが、後者の場合、シェルはそれらを特別な展開修飾子として扱います。"

#: ../../doc_src/language.rst:123
msgid "The special characters and their escape sequences are:"
msgstr "特殊文字とそのエスケープシーケンス::"

#: ../../doc_src/language.rst:127
msgid ""
":code:`\\\\\\ ` (backslash space) escapes the space character. This keeps"
" the shell from splitting arguments on the escaped space."
msgstr ""
":code:`\\\\\\ ` (バックスラッシュ スペース) "
"はスペース文字をエスケープします。これにより、シェルはエスケープされたスペースで引数を分割しなくなります。"

#: ../../doc_src/language.rst:128
msgid "``\\$`` escapes the dollar character."
msgstr "``\\$`` ダラーをエスケープ"

#: ../../doc_src/language.rst:129
msgid "``\\\\`` escapes the backslash character."
msgstr "``\\\\`` バックスラッシュをエスケープ"

#: ../../doc_src/language.rst:130
msgid "``\\*`` escapes the star character."
msgstr "``\\*`` アスタリスクをエスケープ"

#: ../../doc_src/language.rst:131
msgid ""
"``\\?`` escapes the question mark character (this is not necessary if the"
" ``qmark-noglob`` :ref:`feature flag<featureflags>` is enabled)."
msgstr ""
"``\\?`` クエスチョンをエスケープ (``qmark-noglob`` :ref:`機能フラグ<featureflags>` "
"が有効になっている場合は必要ありません)"

#: ../../doc_src/language.rst:132
msgid "``\\~`` escapes the tilde character."
msgstr "``\\~`` チルダをエスケープ"

#: ../../doc_src/language.rst:133
msgid "``\\#`` escapes the hash character."
msgstr "``\\#`` ハッシュをエスケープ"

#: ../../doc_src/language.rst:134
msgid "``\\(`` escapes the left parenthesis character."
msgstr "``\\(`` 左括弧をエスケープ"

#: ../../doc_src/language.rst:135
msgid "``\\)`` escapes the right parenthesis character."
msgstr "``\\)`` 右括弧をエスケープ"

#: ../../doc_src/language.rst:136
msgid "``\\{`` escapes the left curly bracket character."
msgstr "``\\{`` 左中括弧をエスケープ"

#: ../../doc_src/language.rst:137
msgid "``\\}`` escapes the right curly bracket character."
msgstr "``\\}`` 右中括弧をエスケープ"

#: ../../doc_src/language.rst:138
msgid "``\\[`` escapes the left bracket character."
msgstr "``\\[`` 左大括弧をエスケープ"

#: ../../doc_src/language.rst:139
msgid "``\\]`` escapes the right bracket character."
msgstr "``\\]`` 右大括弧をエスケープ"

#: ../../doc_src/language.rst:140
msgid "``\\<`` escapes the less than character."
msgstr "``\\<`` 小なり記号をエスケープ"

#: ../../doc_src/language.rst:141
msgid "``\\>`` escapes the more than character."
msgstr "``\\>`` 大なり記号をエスケープ"

#: ../../doc_src/language.rst:142
msgid "``\\&`` escapes the ampersand character."
msgstr "``\\&`` アンパサンドをエスケープ"

#: ../../doc_src/language.rst:143
msgid "``\\|`` escapes the vertical bar character."
msgstr "``\\|`` 垂直バーをエスケープ"

#: ../../doc_src/language.rst:144
msgid "``\\;`` escapes the semicolon character."
msgstr "``\\;`` セミコロンをエスケープ"

#: ../../doc_src/language.rst:145
msgid "``\\\"`` escapes the quote character."
msgstr "``\\\"`` 二重引用符をエスケープ"

#: ../../doc_src/language.rst:146
msgid "``\\'`` escapes the apostrophe character."
msgstr "``\\'`` アポストロフィをエスケープ"

#: ../../doc_src/language.rst:148
msgid ""
"As a special case, ``\\`` immediately followed by a literal new line is a"
" \"continuation\" and tells fish to ignore the line break and resume "
"input at the start of the next line (without introducing any whitespace "
"or terminating a token)."
msgstr ""
"特別なケースとして、 ``\\`` "
"の直後にリテラルな改行が続く場合は「継続」となり、fishに改行を無視して次の行の先頭から入力を再開するように指示します(空白を挿入したりトークンを終了したりしません)。"

#: ../../doc_src/language.rst:153
msgid "Input/Output Redirection"
msgstr "入力/出力 リダイレクション"

#: ../../doc_src/language.rst:155
msgid "Most programs use three input/output (I/O) streams:"
msgstr "ほとんどのプログラムは3つの入出力(I/O)ストリームを使用します。"

#: ../../doc_src/language.rst:157
msgid "Standard input (stdin) for reading. Defaults to reading from the keyboard."
msgstr "標準入力(stdin)は読み込みます。デフォルトではキーボードから読み込みます。"

#: ../../doc_src/language.rst:158
msgid ""
"Standard output (stdout) for writing output. Defaults to writing to the "
"screen."
msgstr "標準出力(stdout)は書き出します。デフォルトでは画面に出力します。"

#: ../../doc_src/language.rst:159
msgid ""
"Standard error (stderr) for writing errors and warnings. Defaults to "
"writing to the screen."
msgstr "標準エラー出力(stderr)はエラーとワーニングを書き出します。デフォルトでは画面に出力します。"

#: ../../doc_src/language.rst:161
msgid ""
"Each stream has a number called the file descriptor (FD): 0 for stdin, 1 "
"for stdout, and 2 for stderr."
msgstr "各ストリームにはファイルディスクリプタ(FD)と呼ばれる番号があります。0はstdin、1はstdout、2はstderrです。"

#: ../../doc_src/language.rst:163
msgid ""
"The destination of a stream can be changed using something called "
"*redirection*. For example, ``echo hello > output.txt``, redirects the "
"standard output of the ``echo`` command to a text file."
msgstr ""
"ストリームの出力先は、リダイレクトと呼ばれるものを使って変更できます。例えば、 ``echo hello > output.txt`` は、 "
"``echo`` コマンドの標準出力をテキストファイルにリダイレクトします。"

#: ../../doc_src/language.rst:165
msgid "To read standard input from a file, use ``<SOURCE_FILE``."
msgstr "``<SOURCE_FILE`` は標準入力からファイルを読み込みます。"

#: ../../doc_src/language.rst:166
msgid ""
"To read standard input from a file or /dev/null if it can't be read, use "
"``<?SOURCE_FILE``."
msgstr ""
"``<?SOURCE_FILE`` は標準入力からファイルを、読み込めない場合は /dev/null から読み込みます。(訳注: "
"読み込めない場合の挙動が変わります。 ``<`` の場合にはエラーとなり。 ``<?`` の場合にはエラーとなりません。)"

#: ../../doc_src/language.rst:167
msgid "To write standard output to a file, use ``>DESTINATION``."
msgstr "``>DESTINATION`` は標準出力をファイルに書き込みます。"

#: ../../doc_src/language.rst:168
msgid "To write standard error to a file, use ``2>DESTINATION``. [#]_"
msgstr "``2>DESTINATION`` は標準エラー出力をファイルに書き込みます。 [#]_"

#: ../../doc_src/language.rst:169
msgid "To append standard output to a file, use ``>>DESTINATION_FILE``."
msgstr "``>>DESTINATION_FILE`` 標準出力をファイルに追加します。"

#: ../../doc_src/language.rst:170
msgid "To append standard error to a file, use ``2>>DESTINATION_FILE``."
msgstr "``2>>DESTINATION_FILE`` 標準エラー出力をファイルに追加します。"

#: ../../doc_src/language.rst:171
msgid ""
"To not overwrite (\"clobber\") an existing file, use ``>?DESTINATION`` or"
" ``2>?DESTINATION``. This is known as the \"noclobber\" redirection."
msgstr ""
"既存のファイルを上書き(「clobber」)しないようにするには、 ``>?DESTINATION`` と  ``2>?DESTINATION``"
" 使用します。(訳注: 書き込み対象ファイルが存在する場合にはエラーとなります。)"

#: ../../doc_src/language.rst:173
msgid "``DESTINATION`` can be one of the following:"
msgstr "``DESTINATION(宛先)`` は次のいずれかになります:"

#: ../../doc_src/language.rst:175
msgid ""
"A filename to write the output to. Often ``>/dev/null`` to silence output"
" by writing it to the special \"sinkhole\" file."
msgstr "出力を書き込むファイル名。出力を「sinkhole」ファイルに書き込むことで無音にするため、通常は``>/dev/null`` を使用します。"

#: ../../doc_src/language.rst:176
msgid ""
"An ampersand (``&``) followed by the number of another file descriptor "
"like ``&2`` for standard error. The output will be written to the "
"destination descriptor."
msgstr ""
"アンパサンド(``&``)に続けて別のファイルディスクリプタ番号(標準エラーの場合は ``&2`` "
"など)を指定します。出力は宛先記述子に書き込まれます。"

#: ../../doc_src/language.rst:177
msgid ""
"An ampersand followed by a minus sign (``&-``). The file descriptor will "
"be closed. Note: This may cause the program to fail because its writes "
"will be unsuccessful."
msgstr "アンパサンドに続いてマイナス記号(``&-``)です。ファイルディスクリプタは閉じられます。注：これにより、書き込みが失敗し、プログラムが失敗する可能性があります。"

#: ../../doc_src/language.rst:179
msgid ""
"As a convenience, the redirection ``&>`` can be used to direct both "
"stdout and stderr to the same destination. For example, ``echo hello &> "
"all_output.txt`` redirects both stdout and stderr to the file "
"``all_output.txt``. This is equivalent to ``echo hello > all_output.txt "
"2>&1``.  You can also use ``&>>`` to append both stdout and stderr to the"
" same destination."
msgstr ""
"リダイレクト ``&>`` を使用してstdoutとstderrの両方を同じ宛先に向けることができます。たとえば、 ``echo hello &>"
" all_output.txt`` は、stdout と stderr の両方をファイル``all_output.txt`` "
"にリダイレクトします。これは ``echo hello > all_output.txt 2>&1`` と同等です。``&>>`` "
"を使用してstdoutとstderrの両方を同じ出力先に追記することもできます。"

#: ../../doc_src/language.rst:181
msgid ""
"Any arbitrary file descriptor can be used in a redirection by prefixing "
"the redirection with the FD number."
msgstr "リダイレクトの前にFD番号を付けることで、任意のファイルディスクリプタをリダイレクトで使用できます。"

#: ../../doc_src/language.rst:183
msgid "To redirect the input of descriptor N, use ``N<DESTINATION``."
msgstr "``N<DESTINATION`` ディスクリプタ Nの入力をリダイレクトする。"

#: ../../doc_src/language.rst:184
msgid "To redirect the output of descriptor N, use ``N>DESTINATION``."
msgstr "``N>DESTINATION`` ディスクリプタ Nの出力をリダイレクトする。"

#: ../../doc_src/language.rst:185
msgid ""
"To append the output of descriptor N to a file, use "
"``N>>DESTINATION_FILE``."
msgstr "``N>>DESTINATION`` ディスクリプタ Nの出力をファイルに追記する。"

#: ../../doc_src/language.rst:187
msgid ""
"File descriptors cannot be used with a ``<?`` input redirection, only a "
"regular ``<`` one."
msgstr "``<?`` はファイルディスクリプタ(FD)を受け付けません。 ``<`` を使用してください。"

#: ../../doc_src/language.rst:189 ../../doc_src/language.rst:1335
#: ../../doc_src/language.rst:1789 ../../doc_src/language.rst:2148
msgid "For example::"
msgstr "例::"

#: ../../doc_src/language.rst:217
msgid ""
"It is an error to redirect a builtin, function, or block to a file "
"descriptor above 2. However this is supported for external commands."
msgstr "組み込み関数、関数、またはブロックを複数のファイルディスクリプタにリダイレクトすることはできません。ただし、これは外部コマンドではサポートされています。"

#: ../../doc_src/language.rst:219
msgid ""
"Previous versions of fish also allowed specifying this as "
"``^DESTINATION``, but that made another character special so it was "
"deprecated and removed. See :ref:`feature flags<featureflags>`."
msgstr ""
"以前のバージョンでは、 ``^DESTINATION`` として指定できましたが、特殊文字となるため非推奨となり削除されました。 "
":ref:`feature flags<featureflags>` を参照してください。"

#: ../../doc_src/language.rst:224
msgid "Piping"
msgstr ""

#: ../../doc_src/language.rst:226
msgid ""
"Another way to redirect streams is a *pipe*. A pipe connects streams with"
" each other. Usually the standard output of one command is connected with"
" the standard input of another. This is done by separating commands with "
"the pipe character ``|``. For example::"
msgstr ""

#: ../../doc_src/language.rst:230
msgid ""
"The command ``cat foo.txt`` sends the contents of ``foo.txt`` to stdout. "
"This output is provided as input for the ``head`` program, which prints "
"the first 10 lines of its input."
msgstr ""

#: ../../doc_src/language.rst:232
msgid ""
"It is possible to pipe a different output file descriptor by prepending "
"its FD number and the output redirect symbol to the pipe. For example::"
msgstr ""

#: ../../doc_src/language.rst:236
msgid ""
"will attempt to build ``fish``, and any errors will be shown using the "
"``less`` pager. [#]_"
msgstr ""

#: ../../doc_src/language.rst:238
msgid ""
"As a convenience, the pipe ``&|`` redirects both stdout and stderr to the"
" same process. This is different from bash, which uses ``|&``."
msgstr ""

#: ../../doc_src/language.rst:240
msgid ""
"A \"pager\" here is a program that takes output and \"paginates\" it. "
"``less`` doesn't just do pages, it allows arbitrary scrolling (even "
"back!)."
msgstr ""

#: ../../doc_src/language.rst:244
msgid "Combining pipes and redirections"
msgstr ""

#: ../../doc_src/language.rst:246
msgid ""
"It is possible to use multiple redirections and a pipe at the same time. "
"In that case, they are read in this order:"
msgstr ""

#: ../../doc_src/language.rst:248
msgid "First the pipe is set up."
msgstr ""

#: ../../doc_src/language.rst:249
msgid "Then the redirections are evaluated from left-to-right."
msgstr ""

#: ../../doc_src/language.rst:251
msgid ""
"This is important when any redirections reference other file descriptors "
"with the ``&N`` syntax. When you say ``>&2``, that will redirect stdout "
"to where stderr is pointing to *at that time*."
msgstr ""

#: ../../doc_src/language.rst:253
msgid "Consider this helper function::"
msgstr ""

#: ../../doc_src/language.rst:261
msgid "Now let's see a few cases::"
msgstr ""

#: ../../doc_src/language.rst:277
msgid "Job control"
msgstr ""

#: ../../doc_src/language.rst:279
msgid ""
"When you start a job in fish, fish itself will pause, and give control of"
" the terminal to the program it just started. Sometimes, you want to "
"continue using the commandline, and have the job run in the background. "
"To create a background job, append an ``&`` (ampersand) to your command. "
"This will tell fish to run the job in the background. Background jobs are"
" very useful when running programs that have a graphical user interface."
msgstr ""

#: ../../doc_src/language.rst:281 ../../doc_src/language.rst:1139
msgid "Example::"
msgstr "例::"

#: ../../doc_src/language.rst:286
msgid ""
"will start the emacs text editor in the background. :doc:`fg <cmds/fg>` "
"can be used to bring it into the foreground again when needed."
msgstr ""

#: ../../doc_src/language.rst:288
msgid ""
"Most programs allow you to suspend the program's execution and return "
"control to fish by pressing :kbd:`ctrl-z` (also referred to as ``^Z``). "
"Once back at the fish commandline, you can start other programs and do "
"anything you want. If you then want you can go back to the suspended "
"command by using the :doc:`fg <cmds/fg>` (foreground) command."
msgstr ""

#: ../../doc_src/language.rst:290
msgid ""
"If you instead want to put a suspended job into the background, use the "
":doc:`bg <cmds/bg>` command."
msgstr ""

#: ../../doc_src/language.rst:292
msgid ""
"To get a listing of all currently started jobs, use the :doc:`jobs "
"<cmds/jobs>` command. These listed jobs can be removed with the "
":doc:`disown <cmds/disown>` command."
msgstr ""

#: ../../doc_src/language.rst:295
msgid ""
"At the moment, functions cannot be started in the background. Functions "
"that are stopped and then restarted in the background using the :doc:`bg "
"<cmds/bg>` command will not execute correctly."
msgstr ""

#: ../../doc_src/language.rst:297
msgid ""
"If the ``&`` character is followed by a non-separating character, it is "
"not interpreted as background operator. Separating characters are "
"whitespace and the characters ``;<>&|``."
msgstr ""

#: ../../doc_src/language.rst:302
msgid "Functions"
msgstr "関数(ファンクション)"

#: ../../doc_src/language.rst:304
msgid ""
"Functions are programs written in the fish syntax. They group together "
"various commands and their arguments using a single name."
msgstr "関数はfish構文で書かれたプログラムです。関数は、様々なコマンドとその引数を一つの名前でまとめます。"

#: ../../doc_src/language.rst:306
msgid "For example, here's a simple function to list directories::"
msgstr "例えば、ディレクトリを一覧表示する簡単な関数は次のようになります::"

#: ../../doc_src/language.rst:312
msgid ""
"The first line tells fish to define a function by the name of ``ll``, so "
"it can be used by writing ``ll`` on the commandline. The second line "
"tells fish that the command ``ls -l $argv`` should be called when ``ll`` "
"is invoked. :ref:`$argv <variables-argv>` is a :ref:`list variable "
"<variables-lists>`, which always contains all arguments sent to the "
"function. In the example above, these are passed on to the ``ls`` "
"command. The ``end`` on the third line ends the definition."
msgstr ""
"最初の行は、コマンドラインで ``ll`` と入力することで使用できるように、 ``ll`` "
"という名前で関数を定義するように指示しています。2行目は、 ``ll`` が呼び出されたときに ``ls l $argv`` "
"コマンドを実行するように指示しています。 :ref:`$argv <variables-argv>` は :ref:`list variable "
"<variables-lists>` "
"であり、関数に渡されるすべての引数を常に含みます。上記の例では、これらはlsコマンドに渡されます。3行目のendで定義は終了します。"

#: ../../doc_src/language.rst:314
msgid ""
"Calling this as ``ll /tmp/`` will end up running ``ls -l /tmp/``, which "
"will list the contents of /tmp."
msgstr "これを ``ll /tmp/`` として呼び出すと、 ``ls l /tmp/`` が実行され、 /tmp の内容を一覧表示します。"

#: ../../doc_src/language.rst:316
msgid "This is a kind of function known as an :ref:`alias <syntax-aliases>`."
msgstr "これは :ref:`alias <syntax-aliases>` と呼ばれる関数の一種です。"

#: ../../doc_src/language.rst:318
msgid ""
"Fish's prompt is also defined in a function, called :doc:`fish_prompt "
"<cmds/fish_prompt>`. It is run when the prompt is about to be displayed "
"and its output forms the prompt::"
msgstr ""
"Fishのプロンプトは :doc:`fish_prompt <cmds/fish_prompt>` "
"という関数で定義されています。これはプロンプトが表示される直前に実行され、その出力がプロンプトを形成します::"

#: ../../doc_src/language.rst:332
msgid ""
"To edit a function, you can use :doc:`funced <cmds/funced>`, and to save "
"a function :doc:`funcsave <cmds/funcsave>`. This will store it in a "
"function file that fish will :ref:`autoload <syntax-function-"
"autoloading>` when needed."
msgstr ""
"関数を編集するには :doc:`funced <cmds/funced>` を使用し、関数を保存するには :doc:`funcsave "
"<cmds/funcsave>` "
"を使用します。これにより関数はファンクションファイルに保存され、fishは必要に応じて自動的に読み込みます。(:ref:`autoload "
"<syntax-function-autoloading>`)"

#: ../../doc_src/language.rst:334
msgid ""
"The :doc:`functions <cmds/functions>` builtin can show a function's "
"current definition (and :doc:`type <cmds/type>` will also do if given a "
"function)."
msgstr ""
":doc:`functions <cmds/functions>` は現在の関数定義を表示します(関数が与えられた場合、:doc:`type "
"<cmds/type>` も同様に機能します)。"

#: ../../doc_src/language.rst:336
msgid ""
"For more information on functions, see the documentation for the "
":doc:`function <cmds/function>` builtin."
msgstr "関数の詳細については、組み込み :doc:`関数 <cmds/function>` のドキュメントを参照してください。"

#: ../../doc_src/language.rst:341
msgid "Defining aliases"
msgstr "エイリアス定義"

#: ../../doc_src/language.rst:343
msgid ""
"One of the most common uses for functions is to slightly alter the "
"behavior of an already existing command. For example, one might want to "
"redefine the ``ls`` command to display colors. The switch for turning on "
"colors on GNU systems is ``--color=auto``. An alias around ``ls`` might "
"look like this::"
msgstr ""
"関数の最も一般的な用途は、既存のコマンドの動作をわずかに変更することです。例えば、 ``ls`` "
"コマンドをカラー表示に再定義したいとします。GNUシステムではカラー表示を有効にするスイッチは ``--color=auto`` "
"です。lsのエイリアスは次のようになります::"

#: ../../doc_src/language.rst:349
msgid "There are a few important things that need to be noted about aliases:"
msgstr "エイリアスについて注意すべき重要な点がいくつかあります:"

#: ../../doc_src/language.rst:351
msgid ""
"Always take care to add the :ref:`$argv <variables-argv>` variable to the"
" list of parameters to the wrapped command. This makes sure that if the "
"user specifies any additional parameters to the function, they are passed"
" on to the underlying command."
msgstr ""
"ラップされたコマンドのパラメータリストに必ず :ref:`$argv <variables-argv>` "
"変数を追加してください。これにより、ユーザーが関数に追加のパラメータを指定した場合、それらのパラメータが基になるコマンドに渡されるようになります。"

#: ../../doc_src/language.rst:353
msgid ""
"If the alias has the same name as the aliased command, you need to prefix"
" the call to the program with ``command`` to tell fish that the function "
"should not call itself, but rather a command with the same name. If you "
"forget to do so, the function would call itself until the end of time. "
"Usually fish is smart enough to figure this out and will refrain from "
"doing so (which is hopefully in your interest)."
msgstr ""
"エイリアスがコマンドと同じ名前の場合、関数が自分自身を呼び出すのではなく、同じ名前のコマンドを呼び出すように指示するために、プログラムの呼び出しの前に"
" ``command`` "
"を付ける必要があります。これを忘れると、関数は自分自身を呼び出し続けます。通常、fishはこれを理解し、呼び出しを控えます。"

#: ../../doc_src/language.rst:355
msgid ""
"To easily create a function of this form, you can use the :doc:`alias "
"<cmds/alias>` command. Unlike other shells, this just makes functions - "
"fish has no separate concept of an \"alias\", we just use the word for a "
"simple wrapping function like this. :doc:`alias <cmds/alias>` immediately"
" creates a function. Consider using ``alias --save`` or :doc:`funcsave "
"<cmds/funcsave>` to save the created function into an autoload file "
"instead of recreating the alias each time."
msgstr ""
"この形式の関数を簡単に作成するには、 :doc:`alias <cmds/alias>` "
"コマンドを使用します。他のシェルとは異なり、fishには「alias」という概念がないため、関数を単純にラップするだけです。:doc:`alias"
" <cmds/alias>` は即座に関数を作成します。毎回aliasを再作成するのではなく、 ``alias --save`` または "
":doc:`funcsave <cmds/funcsave>` を使用して、作成された関数をオートロードファイルに保存してください。"

#: ../../doc_src/language.rst:357
msgid ""
"For an alternative, try :ref:`abbreviations <abbreviations>`. These are "
"words that are expanded while you type, instead of being actual functions"
" inside the shell."
msgstr ""
"代替案として、 :ref:`略語 <abbreviations>` "
"を試してみてください。略語とは、シェル内で関数としてではなく、入力中に展開される単語です。"

#: ../../doc_src/language.rst:362
msgid "Autoloading functions"
msgstr "関数のオートロード"

#: ../../doc_src/language.rst:364
msgid ""
"Functions can be defined on the commandline or in a configuration file, "
"but they can also be automatically loaded. This has some advantages:"
msgstr "関数はコマンドラインまたは設定ファイルで定義できますが、自動的にロードすることもできます。これにはいくつかの利点があります。"

#: ../../doc_src/language.rst:366
msgid ""
"An autoloaded function becomes available automatically to all running "
"shells."
msgstr "オートロードされた関数は、実行中のすべてのシェルで自動的に利用可能になります。"

#: ../../doc_src/language.rst:367
msgid ""
"If the function definition is changed, all running shells will "
"automatically reload the altered version, after a while."
msgstr "関数定義が変更され、しばらくすると実行中のすべてのシェルが自動的に変更されたバージョンを再読み込みします。"

#: ../../doc_src/language.rst:368
msgid "Startup time and memory usage is improved, etc."
msgstr "その他、起動時間やメモリ使用量が改善されます。"

#: ../../doc_src/language.rst:370
msgid ""
"When fish needs to load a function, it searches through any directories "
"in the :ref:`list variable <variables-lists>` ``$fish_function_path`` for"
" a file with a name consisting of the name of the function plus the "
"suffix ``.fish`` and loads the first it finds."
msgstr ""
"fishが関数をロードする必要がある場合、 :ref:`list variable <variables-lists>` の "
"``$fish_function_path`` 内ディレクトリを検索し、関数名に接尾辞 ``.fish`` "
"が付いた名前のファイルを探し、最初に見つかったものをロードします。"

#: ../../doc_src/language.rst:372
msgid ""
"For example if you try to execute something called ``banana``, fish will "
"go through all directories in $fish_function_path looking for a file "
"called ``banana.fish`` and load the first one it finds."
msgstr ""
"例えば、 ``banana`` という名称の関数を実行しようとすると、fishは $fish_function_path "
"内のすべてのディレクトリを調べて ``banana.fish`` という名称のファイルを探し、最初に見つかったものをロードします。"

#: ../../doc_src/language.rst:374
msgid "By default ``$fish_function_path`` contains the following:"
msgstr "デフォルトでは ``$fish_function_path`` には以下が含まれます::"

#: ../../doc_src/language.rst:376
msgid ""
"A directory for users to keep their own functions, usually "
"``~/.config/fish/functions`` (controlled by the ``XDG_CONFIG_HOME`` "
"environment variable)."
msgstr ""
"ユーザーが独自の関数を保存するためのディレクトリ。通常は ``~/.config/fish/functions`` "
"(``XDG_CONFIG_HOME`` 環境変数によって制御されます)"

#: ../../doc_src/language.rst:377
msgid ""
"A directory for functions for all users on the system, usually "
"``/etc/fish/functions`` (really ``$__fish_sysconfdir/functions``)."
msgstr ""
"システム上のすべてのユーザーの関数のディレクトリ。通常は ``/etc/fish/functions`` (実際は "
"``$__fish_sysconfdir/functions``)"

#: ../../doc_src/language.rst:378
msgid ""
"Directories for other software to put their own functions. These are in "
"the directories under ``$__fish_user_data_dir`` (usually "
"``~/.local/share/fish``, controlled by the ``XDG_DATA_HOME`` environment "
"variable) and in the ``XDG_DATA_DIRS`` environment variable, in a "
"subdirectory called ``fish/vendor_functions.d``. The default value for "
"``XDG_DATA_DIRS`` is usually ``/usr/share/fish/vendor_functions.d`` and "
"``/usr/local/share/fish/vendor_functions.d``."
msgstr ""
"他のソフトウェアが独自の関数を配置するためのディレクトリ。これらは、 ``$__fish_user_data_dir`` (通常は "
"``~/.local/share/fish`` 、 ``XDG_DATA_HOME`` 環境変数によって制御されます)の下のディレクトリと、 "
"``XDG_DATA_DIRS`` 環境変数の ``fish/vendor_functions.d`` というサブディレクトリにあります。 "
"``XDG_DATA_DIRS`` のデフォルト値は通常、 ``/usr/share/fish/vendor_functions.d`` と "
"``/usr/local/share/fish/vendor_functions.d`` です。"

#: ../../doc_src/language.rst:380
msgid ""
"If you are unsure, your functions probably belong in "
"``~/.config/fish/functions``."
msgstr "よくわからない場合、関数はおそらく ``~/.config/fish/functions`` にあるはずです。"

#: ../../doc_src/language.rst:382
msgid ""
"As we've explained, autoload files are loaded *by name*, so, while you "
"can put multiple functions into one file, the file will only be loaded "
"automatically once you try to execute the one that shares the name."
msgstr "説明したように、オートロードファイルは名前でロードされるため、1つのファイルに複数の関数を入れることはできますが、同じ名前を持つ関数を実行しようとしたときにのみ、ファイルが自動的にロードされます。"

#: ../../doc_src/language.rst:384
msgid ""
"Autoloading also won't work for :ref:`event handlers <event>`, since fish"
" cannot know that a function is supposed to be executed when an event "
"occurs when it hasn't yet loaded the function. See the :ref:`event "
"handlers <event>` section for more information."
msgstr ""
"オートロードは :ref:`イベントハンドラ <event>` "
"では機能しません。これは、関数がまだロードされていない場合、イベントが発生したときに関数が実行されるべきかどうかをfishが認識できないためです。詳細については、"
" :ref:`イベントハンドラ <event>` のセクションを参照してください。"

#: ../../doc_src/language.rst:386
msgid ""
"If a file of the right name doesn't define the function, fish will not "
"read other autoload files, instead it will go on to try builtins and "
"finally commands. This allows masking a function defined later in "
"$fish_function_path, e.g. if your administrator has put something into "
"/etc/fish/functions that you want to skip."
msgstr ""
"ファイルと関数を同じ名称で定義していない場合、fishは他の自動ロードファイルを読み込まず、代わりに組み込みコマンドを試し、最終的にコマンドを実行します。これにより、"
" $fish_function_path 内に後から定義した関数でマスクできます。たとえば、管理者が /etc/fish/functions "
"に入れた関数をスキップしたい場合などです。"

#: ../../doc_src/language.rst:388
msgid ""
"If you are developing another program and want to install fish functions "
"for it, install them to the \"vendor\" functions directory. As this path "
"varies from system to system, you can use ``pkgconfig`` to discover it "
"with the output of ``pkg-config --variable functionsdir fish``. Your "
"installation system should support a custom path to override the "
"pkgconfig path, as other distributors may need to alter it easily."
msgstr ""
"別のプログラムを開発していて、そこにfish関数をインストールしたい場合は、「ベンダー」関数ディレクトリにインストールします。このパスはシステムによって異なるため、"
" ``pkgconfig`` を使用し ``pkg-config --variable functionsdir fish`` "
"の出力から検出します。他のディストリビュータが簡単に変更可能とするため、インストールシステムはpkgconfigパスを上書きするためのカスタムパスをサポートする必要があります。"

#: ../../doc_src/language.rst:393
msgid "Comments"
msgstr ""

#: ../../doc_src/language.rst:395
msgid ""
"Anything after a ``#`` until the end of the line is a comment. That means"
" it's purely for the reader's benefit, fish ignores it."
msgstr ""

#: ../../doc_src/language.rst:397
msgid "This is useful to explain what and why you are doing something::"
msgstr ""

#: ../../doc_src/language.rst:405
msgid ""
"There are no multiline comments. If you want to make a comment span "
"multiple lines, start each line with a ``#``."
msgstr ""

#: ../../doc_src/language.rst:407
msgid "Comments can also appear after a line like so::"
msgstr ""

#: ../../doc_src/language.rst:414
msgid "Conditions"
msgstr "条件"

#: ../../doc_src/language.rst:416
msgid ""
"Fish has some builtins that let you execute commands only if a specific "
"criterion is met: :doc:`if <cmds/if>`, :doc:`switch <cmds/switch>`, "
":doc:`and <cmds/and>` and :doc:`or <cmds/or>`, and also the familiar "
":ref:`&&/|| <syntax-combiners>` syntax."
msgstr ""
"Fishには、特定の条件が満たされた場合にのみコマンドを実行できる組み込み関数がいくつかあります。:doc:`if <cmds/if>`, "
":doc:`switch <cmds/switch>`, :doc:`and <cmds/and>` and :doc:`or "
"<cmds/or>` そして :ref:`&&/|| <syntax-combiners>` 構文です。"

#: ../../doc_src/language.rst:421
msgid "The ``if`` statement"
msgstr "``if`` 構文"

#: ../../doc_src/language.rst:423
msgid ""
"The :doc:`if <cmds/if>` statement runs a block of commands if the "
"condition was true."
msgstr ":doc:`if <cmds/if>` 構文は条件が真であればコマンドブロックを実行します"

#: ../../doc_src/language.rst:425
msgid ""
"Like other shells, but unlike typical programming languages you might "
"know, the condition here is a *command*. Fish runs it, and if it returns "
"a true :ref:`exit status <variables-status>` (that's 0), the if-block is "
"run. For example::"
msgstr ""
"他のシェルと同様ですが、一般的なプログラミング言語とは異なり、ここでの条件は *コマンド* です。Fishはそれを実行し、真の "
":ref:`終了ステータス <variables-status>` (つまり0)を返した場合、ifブロックが実行されます。例えば::"

#: ../../doc_src/language.rst:431
msgid ""
"This uses the :doc:`test <cmds/test>` command to see if the file /etc/os-"
"release exists. If it does, it runs ``cat``, which prints it on the "
"screen."
msgstr ""
"これは :doc:`test <cmds/test>` コマンドを使って /etc/os-release "
"ファイルが存在するかどうかを確認します。存在する場合はcatコマンドを実行し、画面に出力します。"

#: ../../doc_src/language.rst:433
msgid ""
"Unlike other shells, the condition command ends after the first job, "
"there is no ``then`` here. Combiners like ``and`` and ``or`` extend the "
"condition."
msgstr ""
"他のシェルとは異なり、条件コマンドは最初のジョブの後に終了し、 ``then`` は存在しません。 ``and`` や ``or`` "
"のような結合子は条件を拡張します。"

#: ../../doc_src/language.rst:435
msgid ""
"A more complicated example with a :ref:`command substitution <expand-"
"command-substitution>`::"
msgstr " :ref:`コマンド置換 <expand-command-substitution>` を使用した複雑な例::"

#: ../../doc_src/language.rst:441
msgid ""
"Because ``test`` can be used for many different tests, it is important to"
" quote variables and command substitutions. If the ``$(uname)`` was not "
"quoted, and ``uname`` printed nothing it would run ``test = Linux``, "
"which is an error."
msgstr ""
"``test`` はさまざまな判定に使用できるため、変数とコマンド置換を引用符で囲むことが重要です。``$(uname)`` "
"が引用符で囲まれておらず、 ``uname`` が何も出力しない場合は、 ``test = Linux`` が実行され、エラーが発生します。"

#: ../../doc_src/language.rst:443
msgid ""
"``if`` can also take ``else if`` clauses with additional conditions and "
"an  :doc:`else <cmds/else>` clause that is executed when everything else "
"was false::"
msgstr ""
"``if`` は、追加の条件を持つ ``else if`` 節と、他のすべてが偽であった場合に実行される :doc:`else "
"<cmds/else>` 節を取ることもできます::"

#: ../../doc_src/language.rst:455
msgid "The :doc:`not <cmds/not>` keyword can be used to invert the status::"
msgstr ":doc:`not <cmds/not>` はステータスを反転するために使用できます::"

#: ../../doc_src/language.rst:468
msgid "Other things commonly used in if-conditions:"
msgstr "if条件でよく使われるその他のもの"

#: ../../doc_src/language.rst:470
msgid ""
":doc:`contains <cmds/contains>` - to see if a list contains a specific "
"element (``if contains -- /usr/bin $PATH``)"
msgstr ""
":doc:`contains <cmds/contains>` - リストに特定の要素が含まれているかどうかを確認します(``if "
"contains -- /usr/bin $PATH``)"

#: ../../doc_src/language.rst:471
msgid ""
":doc:`string <cmds/string>` - to e.g. match strings (``if string match -q"
" -- '*-' $arg``)"
msgstr ""
":doc:`string <cmds/string>` - 文字列を一致させる例 (``if string match -q -- '*-' "
"$arg``)"

#: ../../doc_src/language.rst:472
msgid ""
":doc:`path <cmds/path>` - to check if paths of some criteria exist (``if "
"path is -rf -- ~/.config/fish/config.fish``)"
msgstr ""
":doc:`path <cmds/path>` - 特定の基準を満たすパスが存在するかどうかを確認する (``if path is -rf -- "
"~/.config/fish/config.fish``)"

#: ../../doc_src/language.rst:473
msgid ""
":doc:`type <cmds/type>` - to see if a command, function or builtin exists"
" (``if type -q git``)"
msgstr ""
":doc:`type <cmds/type>` - コマンド、関数、または組み込み関数が存在するかどうかを確認する (``if type -q "
"git``)"

#: ../../doc_src/language.rst:476
msgid "The ``switch`` statement"
msgstr "``switch`` 構文"

#: ../../doc_src/language.rst:478
msgid ""
"The :doc:`switch <cmds/switch>` command is used to execute one of "
"possibly many blocks of commands depending on the value of a string. It "
"can take multiple :doc:`case <cmds/case>` blocks that are executed when "
"the string matches. They can take :ref:`wildcards <expand-wildcard>`. For"
" example::"
msgstr ""
":doc:`switch <cmds/switch>` "
"コマンドは、文字列の値に応じて、複数のコマンドブロックのいずれかを実行するために使用されます。文字列が一致した場合に実行される "
":doc:`case <cmds/case>` ブロックを複数指定できます。caseブロックには :ref:`wildcards <expand-"
"wildcard>` を使用できます。例えば::"

#: ../../doc_src/language.rst:491
msgid ""
"Unlike other shells or programming languages, there is no fallthrough - "
"the first matching ``case`` block is executed and then control jumps out "
"of the ``switch``."
msgstr ""
"他のシェルやプログラミング言語とは異なり、フォールスルーはなく、最初に一致する ``case`` ブロックが実行され、その後制御が "
"``switch`` ブロックが終了します。"

#: ../../doc_src/language.rst:496
msgid "Combiners (``and`` / ``or`` / ``&&`` / ``||``)"
msgstr "結合演算子 (``and`` / ``or`` / ``&&`` / ``||``)"

#: ../../doc_src/language.rst:498
msgid ""
"For simple checks, you can use combiners. :doc:`and <cmds/and>` or ``&&``"
" run the second command if the first succeeded, while :doc:`or <cmds/or>`"
" or ``||`` run it if the first failed. For example::"
msgstr ""
"単純なチェックには結合演算子を使うことができます。:doc:`and <cmds/and>` 、 ``&&`` "
"は最初のコマンドが成功した場合に2番目のコマンドを実行。:doc:`or <cmds/or>` "
"は最初のコマンドが失敗した場合に2番目のコマンドを実行します。例えば::"

#: ../../doc_src/language.rst:505
msgid ""
"Note that combiners are *lazy* - only the part that is necessary to "
"determine the final status is run."
msgstr "結合演算子は *遅延評価* されます。最終的なステータスを決定するために必要な部分のみ実行されることに注意してください。"

#: ../../doc_src/language.rst:507
msgid "Compare::"
msgstr "比較::"

#: ../../doc_src/language.rst:513
msgid "and::"
msgstr "と::"

#: ../../doc_src/language.rst:519
msgid ""
"These do essentially the same thing, but the former takes 2 seconds "
"longer because the ``sleep`` always needs to run."
msgstr "これらは本質的に同じことを行いますが、前者は ``sleep`` を常に実行する必要があるため、2秒長くかかります。"

#: ../../doc_src/language.rst:521
msgid "Or you can have a case where it is necessary to stop early::"
msgstr "あるいは、早期に停止する必要がある場合もあります::"

#: ../../doc_src/language.rst:525
msgid ""
"If this went on after seeing that the command \"foo\" doesn't exist, it "
"would try to run ``foo`` and error because it wasn't found!"
msgstr "コマンド「foo」が存在しないことを確認した後にこれを実行した場合、 ``foo`` を実行しようとすると、見つからないためエラーが発生します。"

#: ../../doc_src/language.rst:527
msgid ""
"Combiners execute step-by-step, so it isn't recommended to build longer "
"chains of them because they might do something you don't want. Consider::"
msgstr "結合演算子は段階的に実行され、望ましくない結果をもたらす可能性があります。長いチェーンを構築することは推奨されません::"

#: ../../doc_src/language.rst:533
msgid ""
"This will execute ``return 1`` also if the ``test`` succeeded. This is "
"because fish runs ``test -e /etc/my.config``, sets $status to 0, then "
"skips the ``echo``, keeps $status at 0, and then executes the ``return "
"1`` because $status is still 0."
msgstr ""
"これは、テストが成功した場合も ``return 1`` を実行します。これは、fish が ``test -e /etc/my.config``"
" を実行し、$status を 0 に設定した後、 ``echo`` をスキップして $status を 0 のままにし、$status がまだ "
"0 であるため ``return 1`` を実行するためです。"

#: ../../doc_src/language.rst:535
msgid ""
"So if you have more complex conditions or want to run multiple things "
"after something failed, consider using an :ref:`if <syntax-if>`. Here "
"that would be::"
msgstr "より複雑な条件や、何かが失敗した後に複数の処理を実行したい場合は、 :ref:`if <syntax-if>` 文の使用を検討してください::"

#: ../../doc_src/language.rst:545
msgid "Loops and blocks"
msgstr "ループとブロック"

#: ../../doc_src/language.rst:547
msgid ""
"Like most programming language, fish also has the familiar :doc:`while "
"<cmds/while>` and :doc:`for <cmds/for>` loops."
msgstr ""
"ほとんどのプログラミング言語と同様に、fishにもおなじみの :doc:`while <cmds/while>` ループと :doc:`for "
"<cmds/for>` ループがあります。"

#: ../../doc_src/language.rst:549
msgid "``while`` works like a repeated :ref:`if <syntax-if>`::"
msgstr "``while`` は繰り返しの :ref:`if <syntax-if>` のように動作します。::"

#: ../../doc_src/language.rst:556
msgid "will print \"Still running\" once a second. You can abort it with ctrl-c."
msgstr "1秒ごとに「Still running」と表示されます。ctrl + cで中止できます。"

#: ../../doc_src/language.rst:558
msgid ""
"``for`` loops work like in other shells, which is more like python's for-"
"loops than e.g. C's::"
msgstr "``for`` ループは他のシェルと同じように動作します。これはC言語のforループよりもPythonのforループに似ています。"

#: ../../doc_src/language.rst:564
msgid ""
"will print each file in the current directory. The part after the ``in`` "
"is a list of arguments, so you can use any :ref:`expansions <expand>` "
"there::"
msgstr ""
"現在のディレクトリにある各ファイルを表示します。 ``in`` の後の部分は引数のリストなので、任意の :ref:`展開(expansions) "
"<expand>` を使用できます。"

#: ../../doc_src/language.rst:571
msgid ""
"If you need a list of numbers, you can use the ``seq`` command to create "
"one::"
msgstr "数字のリストが必要な場合は、 ``seq`` コマンドを使用して作成できます。"

#: ../../doc_src/language.rst:577
msgid ""
":doc:`break <cmds/break>` is available to break out of a loop, and "
":doc:`continue <cmds/continue>` to jump to the next iteration."
msgstr ""
":doc:`break <cmds/break>` はループから抜け出し、 :doc:`continue <cmds/continue>` "
"は次の反復にジャンプするために使用できます。"

#: ../../doc_src/language.rst:579
msgid ""
":ref:`Input and output redirections <redirects>` (including :ref:`pipes "
"<pipes>`) can also be applied to loops::"
msgstr ":ref:`入力と出力のリダイレクト <redirects>` (:ref:`パイプ <pipes>` 含む)はループにも適用できます::"

#: ../../doc_src/language.rst:585
msgid ""
"In addition there's a :doc:`begin <cmds/begin>` block that just groups "
"commands together so you can redirect to a block or use a new "
":ref:`variable scope <variables-scope>` without any repetition::"
msgstr ""
"さらに、コマンドをグループ化する :doc:`begin <cmds/begin>` "
"ブロックがあるので、ブロックにリダイレクトしたり、繰り返しなしで新しい :ref:`variable scope <variables-"
"scope>` スコープを使用したりできます::"

#: ../../doc_src/language.rst:594
msgid "Parameter expansion"
msgstr "パラメータ展開"

#: ../../doc_src/language.rst:596
msgid ""
"When fish is given a commandline, it expands the parameters before "
"sending them to the command. There are multiple different kinds of "
"expansions:"
msgstr "fishはコマンドラインを受け取ると、コマンドに渡す前にパラメータを展開します。展開には、以下のような複数の異なる種類があります。"

#: ../../doc_src/language.rst:598
msgid ""
":ref:`Wildcards <expand-wildcard>`, to create filenames from patterns - "
"``*.jpg``"
msgstr ":ref:`ワイルドカード <expand-wildcard>`: パターンからファイル名を作成します - ``*.jpg``"

#: ../../doc_src/language.rst:599
msgid ""
":ref:`Variable expansion <expand-variable>`, to use the value of a "
"variable - ``$HOME``"
msgstr ":ref:`変数展開 <expand-variable>`: 変数の値を使用します - ``$HOME``"

#: ../../doc_src/language.rst:600
msgid ""
":ref:`Command substitution <expand-command-substitution>`, to use the "
"output of another command - ``$(cat /path/to/file)``"
msgstr ""
":ref:`コマンド置換 <expand-command-substitution>`: 他のコマンドの出力を利用します - ``$(cat "
"/path/to/file)``"

#: ../../doc_src/language.rst:601
#, python-brace-format
msgid ""
":ref:`Brace expansion <expand-brace>`, to write lists with common pre- or"
" suffixes in a shorter way ``{/usr,}/bin``"
msgstr ":ref:`ブレース展開 <expand-brace>`: 共通の接頭辞や接尾辞を持つリストを短く記述します ``{/usr,}/bin``"

#: ../../doc_src/language.rst:602
msgid ""
":ref:`Tilde expansion <expand-home>`, to turn the ``~`` at the beginning "
"of paths into the path to the home directory ``~/bin``"
msgstr ":ref:`チルダ展開 <expand-home>`: パスの先頭にある ~ をホームディレクトリへのパスに変換します ``~/bin``"

#: ../../doc_src/language.rst:604
msgid ""
"Parameter expansion is limited to 524288 items. There is a limit to how "
"many arguments the operating system allows for any command, and 524288 is"
" far above it. This is a measure to stop the shell from hanging doing "
"useless computation."
msgstr "パラメータ展開は524,288個までに制限されています。オペレーティングシステムがコマンドに許可する引数の数には制限があり、524,288はその制限を大きく上回っています。これは、シェルが無益な計算によってハングアップするのを防ぐための措置です。"

#: ../../doc_src/language.rst:609
msgid "Wildcards (\"Globbing\")"
msgstr "ワイルドカード(グロビング)"

#: ../../doc_src/language.rst:611
msgid ""
"When a parameter includes an :ref:`unquoted <quotes>` ``*`` star (or "
"\"asterisk\") or a ``?`` question mark, fish uses it as a wildcard to "
"match files."
msgstr ""
"パラメータに :ref:`引用符で囲まれていない <quotes>` ``*`` (アスタリスク)または ``?`` "
"(疑問符)が含まれている場合、fishはそれらをファイルにマッチさせるためのワイルドカードとして使用します。"

#: ../../doc_src/language.rst:613
msgid ""
"``*`` matches any number of characters (including zero) in a file name, "
"not including ``/``."
msgstr "``*`` は、ファイル名に含まれる(0文字以上の)任意の数の文字にマッチします。これに ``/`` は含まれません。"

#: ../../doc_src/language.rst:615
msgid ""
"``**`` matches any number of characters (including zero), and also "
"descends into subdirectories. If ``**`` is a segment by itself, that "
"segment may match zero times, for compatibility with other shells."
msgstr ""
"``**`` は(0文字以上の)任意の数の文字にマッチし、サブディレクトリ内も再帰的に検索します。``**`` "
"が単独のセグメントである場合、他のシェルとの互換性のために、そのセグメントは0回(マッチなし)とみなされる場合があります。"

#: ../../doc_src/language.rst:617
msgid ""
"``?`` can match any single character except ``/``. This is deprecated and"
" can be disabled via the ``qmark-noglob`` :ref:`feature "
"flag<featureflags>`, so ``?`` will be an ordinary character."
msgstr ""
"``?`` は ``/`` を除く任意の1文字にマッチします。これは非推奨となっており、``qmark-noglob`` :ref:`機能フラグ "
"<featureflags>` を通じて無効化できます。無効化された場合、``?`` は通常の文字として扱われます。"

#: ../../doc_src/language.rst:619
msgid ""
"Wildcard matches are sorted case insensitively. When sorting matches "
"containing numbers, they are naturally sorted, so that the strings '1' "
"'5' and '12' would be sorted like 1, 5, 12."
msgstr ""
"ワイルドカードによる一致結果は、大文字と小文字を区別せずにソートされます。数値を含む結果をソートする場合、'1'、'5'、'12' "
"のような文字列が 1、5、12 の順になるよう、自然順でソートされます。"

#: ../../doc_src/language.rst:621
msgid ""
"Hidden files (where the name begins with a dot) are not considered when "
"wildcarding unless the wildcard string has a dot in that place."
msgstr "隠しファイル(名前がドットで始まるもの)は、ワイルドカード文字列のその場所にドットがない限り、マッチングの対象になりません。"

#: ../../doc_src/language.rst:623
msgid "Examples:"
msgstr "例:"

#: ../../doc_src/language.rst:625
msgid "``a*`` matches any files beginning with an 'a' in the current directory."
msgstr "``a*`` は、カレントディレクトリ内にある 'a' で始まるすべてのファイルにマッチします。"

#: ../../doc_src/language.rst:627
msgid ""
"``**`` matches any files and directories in the current directory and all"
" of its subdirectories."
msgstr "``**`` は、カレントディレクトリおよびそのすべてのサブディレクトリ内にあるすべてのファイルとディレクトリにマッチします。"

#: ../../doc_src/language.rst:629
msgid ""
"``~/.*`` matches all hidden files (also known as \"dotfiles\") and "
"directories in your home directory."
msgstr "``~/.*`` は、ホームディレクトリ内にあるすべての隠しファイル(「ドットファイル」とも呼ばれます)とディレクトリにマッチします。"

#: ../../doc_src/language.rst:631
msgid ""
"For most commands, if any wildcard fails to expand, the command is not "
"executed, :ref:`$status <variables-status>` is set to nonzero, and a "
"warning is printed. This behavior is like what bash does with ``shopt -s "
"failglob``. There are exceptions, namely :doc:`set <cmds/set>` and "
":doc:`path <cmds/path>`, overriding variables in :ref:`overrides "
"<variables-override>`, :doc:`count <cmds/count>` and :doc:`for "
"<cmds/for>`. Their globs will instead expand to zero arguments (so the "
"command won't see them at all), like with ``shopt -s nullglob`` in bash."
msgstr ""
"ほとんどのコマンドにおいて、ワイルドカードの展開に一つでも失敗すると、そのコマンドは実行されず、:ref:`$status <variables-"
"status>` に非ゼロの値が設定され、警告が表示されます。この挙動は、bashで ``shopt -s failglob`` "
"を設定した場合と同様です。ただし例外もあり、具体的には :doc:`set <cmds/set>`、:doc:`path "
"<cmds/path>`、:ref:`変数の一時的な上書き <variables-override>`、:doc:`count "
"<cmds/count>`、および :doc:`for <cmds/for>` "
"が該当します。これらのコマンドでは、グロブは(コマンド側からは何も見えないように)0個の引数に展開されます。これはbashで ``shopt -s"
" nullglob`` を設定した場合と同様です。"

#: ../../doc_src/language.rst:633 ../../doc_src/language.rst:839
#: ../../doc_src/language.rst:877
msgid "Examples::"
msgstr "例:"

#: ../../doc_src/language.rst:644
msgid ""
"Unlike bash (by default), fish will not pass on the literal glob "
"character if no match was found, so for a command like ``apt install`` "
"that does the matching itself, you need to add quotes::"
msgstr ""
"(デフォルトの)bashとは異なり、fishは一致するものが見つからなかった場合にグロブ文字をそのまま渡しません。そのため、``apt "
"install`` のようにコマンド側でマッチングを行う場合は、以下のように引用符を追加する必要があります。"

#: ../../doc_src/language.rst:651
msgid "Variable expansion"
msgstr "変数展開"

#: ../../doc_src/language.rst:653
msgid ""
"One of the most important expansions in fish is the \"variable "
"expansion\". This is the replacing of a dollar sign (``$``) followed by a"
" variable name with the _value_ of that variable."
msgstr "fishにおける最も重要な展開の一つが「変数展開」です。これは、ドル記号(``$``)に続く変数名を、その変数の「値」に置き換える処理です。"

#: ../../doc_src/language.rst:655
msgid "A simple example::"
msgstr "簡単な例::"

#: ../../doc_src/language.rst:659
msgid ""
"which will replace ``$HOME`` with the home directory of the current user,"
" and pass it to :doc:`echo <cmds/echo>`, which will then print it."
msgstr ""
"これは ``$HOME`` を現在のユーザーのホームディレクトリに置き換え、それを :doc:`echo <cmds/echo>` "
"に渡して表示します。"

#: ../../doc_src/language.rst:661
msgid ""
"Some variables like ``$HOME`` are already set because fish sets them by "
"default or because fish's parent process passed them to fish when it "
"started it. You can define your own variables by setting them with "
":doc:`set <cmds/set>`::"
msgstr ""
"``$HOME`` "
"のような一部の変数は、fishがデフォルトで設定しているか、fishの親プロセスが起動時に渡しているため、あらかじめ設定されています。独自の変数は"
" :doc:`set <cmds/set>` を使って定義できます。"

#: ../../doc_src/language.rst:667
msgid ""
"For more on how setting variables works, see :ref:`Shell variables "
"<variables>` and the following sections."
msgstr "変数設定の仕組みの詳細については、:ref:`シェル変数 <variables>` とそれに続くセクションを参照してください。"

#: ../../doc_src/language.rst:669
msgid ""
"Sometimes a variable has no value because it is undefined or empty, and "
"it expands to nothing::"
msgstr "変数が未定義または空であるために値を持たず、「無」として展開されることもあります::"

#: ../../doc_src/language.rst:674
msgid ""
"To separate a variable name from text you can encase the variable within "
"double-quotes or braces::"
msgstr "変数名とテキストを区別するために、変数を二重引用符(ダブルクォート)または中括弧(ブレース)で囲むことができます::"

#: ../../doc_src/language.rst:682
msgid ""
"Without the quotes or braces, fish will try to expand a variable called "
"``$WORDs``, which may not exist."
msgstr "引用符や中括弧がない場合、fishは存在しない可能性のある ``$WORDs`` という名前の変数を展開しようとします。"

#: ../../doc_src/language.rst:684
#, python-brace-format
msgid ""
"The latter syntax ``{$WORD}`` is a special case of :ref:`brace expansion "
"<expand-brace>`."
msgstr "後者の ``{$WORD}`` という構文は、 :ref:`ブレース展開 <expand-brace>` の特殊なケースです。"

#: ../../doc_src/language.rst:686
msgid ""
"If $WORD here is undefined or an empty list, the \"s\" is not printed. "
"However, it is printed if $WORD is the empty string (like after ``set "
"WORD \"\"``)."
msgstr ""
"ここで $WORD が未定義または空のリストである場合、 \"s\" は表示されません。しかし、$WORD が空の文字列である場合(``set "
"WORD \"\"`` の後など)は、\"s\" は表示されます。"

#: ../../doc_src/language.rst:688
msgid ""
"For more on shell variables, read the :ref:`Shell variables <variables>` "
"section."
msgstr "シェル変数の詳細については、 :ref:`シェル変数 <variables>` セクションを参照してください。"

#: ../../doc_src/language.rst:691
msgid "Quoting variables"
msgstr "変数のクォーティング"

#: ../../doc_src/language.rst:693
msgid ""
"Variable expansion also happens in double quoted strings. Inside double "
"quotes (``\"these\"``), variables will always expand to exactly one "
"argument. If they are empty or undefined, it will result in an empty "
"string. If they have one element, they'll expand to that element. If they"
" have more than that, the elements will be joined with spaces, unless the"
" variable is a :ref:`path variable <variables-path>` - in that case it "
"will use a colon (``:``) instead [#]_."
msgstr ""
"変数展開は二重引用符で囲まれた文字列内でも行われます。二重引用符(``\"これ\"``)の中では、変数は常に正確に1つの引数として展開されます。変数が空または未定義の場合は、空の文字列になります。要素が1つの場合は、その要素に展開されます。要素が複数ある場合は、各要素がスペースで結合されます。ただし、その変数が"
" :ref:`パス変数 <variables-path>` である場合は、代わりにコロン(``:``)で結合されます [#]_。"

#: ../../doc_src/language.rst:695
msgid ""
"Fish variables are all :ref:`lists <variables-lists>`, and they are split"
" into elements when they are *set* - that means it is important to decide"
" whether to use quotes or not with :doc:`set <cmds/set>`::"
msgstr ""
"fishの変数はすべて :ref:`リスト <variables-lists>` "
"であり、これらは「設定」(*set*)された時に要素へと分割されます。つまり、 :doc:`set <cmds/set>` "
"を使用する際に引用符を使うか使わないかを決めることが重要になります::"

#: ../../doc_src/language.rst:709
msgid ""
"This is unlike other shells, which do what is known as \"Word "
"Splitting\", where they split the variable when it is *used* in an "
"expansion. E.g. in bash:"
msgstr ""
"これは他のシェルとは異なります。他のシェルでは「ワードスプリッティング(単語の分割)」として知られる処理が行われ、変数が展開に *使用* "
"される時に分割されます。例えばbashでは以下のようになります:"

#: ../../doc_src/language.rst:717
msgid ""
"This is the cause of very common problems with filenames with spaces in "
"bash scripts."
msgstr "これは、bashスクリプトにおいてスペースを含むファイル名で非常によく発生する問題の原因となっています。"

#: ../../doc_src/language.rst:719
msgid ""
"In fish, unquoted variables will expand to as many arguments as they have"
" elements. That means an empty list will expand to nothing, a variable "
"with one element will expand to that element, and a variable with "
"multiple elements will expand to each of those elements separately."
msgstr "fishでは、引用符で囲まれていない変数はその要素の数だけ引数として展開されます。つまり、空のリストは「無」に展開され、1つの要素を持つ変数はその要素に展開され、複数の要素を持つ変数はそれぞれの要素に個別に展開されます。"

#: ../../doc_src/language.rst:721
msgid ""
"If a variable expands to nothing, it will cancel out any other strings "
"attached to it. See the :ref:`Combining Lists <cartesian-product>` "
"section for more information."
msgstr ""
"変数が「無」として展開される場合、その変数に付随する他の文字列も取り消されます。詳細については、 :ref:`リストの結合 <cartesian-"
"product>` セクションを参照してください。"

#: ../../doc_src/language.rst:723
msgid ""
"Most of the time, not quoting a variable is correct. The exception is "
"when you need to ensure that the variable is passed as one element, even "
"if it might be unset or have multiple elements. This happens often with "
":doc:`test <cmds/test>`::"
msgstr ""
"ほとんどの場合、変数に引用符を付けないのが正解です。例外は、変数が未設定であったり複数の要素を持っていたりする場合でも、必ず1つの要素として渡す必要がある場合です。これは"
" :doc:`test <cmds/test>` でよく発生します::"

#: ../../doc_src/language.rst:734
msgid ""
"Unlike bash or zsh, which will join with the first character of $IFS "
"(which usually is space)."
msgstr "(通常はスペースである)$IFS の最初の文字で結合するbashやzshとは異なります。"

#: ../../doc_src/language.rst:737
msgid "Dereferencing variables"
msgstr "変数のデリファレンス(逆参照)"

#: ../../doc_src/language.rst:739
msgid ""
"The ``$`` symbol can also be used multiple times, as a kind of "
"\"dereference\" operator (the ``*`` in C or C++), like in the following "
"code::"
msgstr ""
"``$`` 記号を複数回使用することで、(C言語やC++の ``*`` "
"のような)一種の「デリファレンス」演算子として扱うことができます。以下のコードのようになります。"

#: ../../doc_src/language.rst:752
msgid "``$$foo[$i]`` is \"the value of the variable named by ``$foo[$i]``\"."
msgstr "``$$foo[$i]`` は、「 ``$foo[$i]`` という名前を持つ変数の値」を意味します。"

#: ../../doc_src/language.rst:754
msgid "This can also be used to give a variable name to a function::"
msgstr "これは、関数に変数の名前を渡すためにも使用できます。"

#: ../../doc_src/language.rst:768
msgid ""
"Of course the variable will have to be accessible from the function, so "
"it needs to be :ref:`global/universal <variables-scope>` or "
":ref:`exported <variables-export>`. It also can't clash with a variable "
"name used inside the function. So if we had made $foo there a local "
"variable, or if we had named it \"arg\" instead, it would not have "
"worked."
msgstr ""
"当然ながら、その変数は関数からアクセス可能である必要があるため、 :ref:`グローバルまたはユニバーサル <variables-scope>` "
"であるか、 :ref:`エクスポート <variables-export>` "
"されている必要があります。また、関数内部で使用されている変数名と衝突してはいけません。したがって、もし $foo "
"をローカル変数にしていたり、あるいは名前を \"arg\" にしていたりすると、正しく動作しません。"

#: ../../doc_src/language.rst:770
msgid ""
"When using this feature together with :ref:`slices <expand-slices>`, the "
"slices will be used from the inside out. ``$$foo[5]`` will use the fifth "
"element of ``$foo`` as a variable name, instead of giving the fifth "
"element of all the variables $foo refers to. That would instead be "
"expressed as ``$$foo[1..-1][5]`` (take all elements of ``$foo``, use them"
" as variable names, then give the fifth element of those)."
msgstr ""
"この機能を :ref:`スライス <expand-slices>` と組み合わせて使用する場合、スライスは内側から外側に向かって適用されます。 "
"``$$foo[5]`` は、 ``$foo`` が参照するすべての変数の5番目の要素を返すのではなく、 ``$foo`` "
"の5番目の要素を変数名として使用します。前者の挙動をさせたい場合は、 ``$$foo[1..-1][5]`` ( ``$foo`` "
"のすべての要素を取得し、それらを変数名として使用した上で、それらの5番目の要素を返す)と記述します。"

#: ../../doc_src/language.rst:772
msgid "Some more examples::"
msgstr "さらなる例::"

#: ../../doc_src/language.rst:791
msgid "Variables as command"
msgstr "コマンドとしての変数"

#: ../../doc_src/language.rst:793
msgid "Like other shells, you can run the value of a variable as a command."
msgstr "他のシェルと同様に、変数の値をコマンドとして実行できます。"

#: ../../doc_src/language.rst:800
msgid ""
"If you want to give the command an argument inside the variable it needs "
"to be a separate element::"
msgstr ""

#: ../../doc_src/language.rst:807
msgid ""
"Also like other shells, this only works with commands, builtins and "
"functions - it will not work with keywords because they have syntactical "
"importance."
msgstr "また、他のシェルと同様に、これが機能するのは外部コマンド、組み込みコマンド、関数のみです。キーワードについては、構文上の重要な意味を持つため機能しません。"

#: ../../doc_src/language.rst:809
msgid ""
"For instance ``set if $if`` won't allow you to make an if-block, and "
"``set cmd command`` won't allow you to use the :doc:`command "
"<cmds/command>` decorator, but only uses like ``$cmd -q foo``."
msgstr ""
"例えば、``set if $if`` とした後に ``$if`` を使っても ifブロックを作成することはできません。同様に ``set cmd "
"command`` としても、 :doc:`command <cmds/command>` デコレータとして使用することはできず、 ``$cmd "
"-q foo`` のような(外部コマンドとしての)利用に限られます。"

#: ../../doc_src/language.rst:815
msgid "Command substitution"
msgstr "コマンド置換"

#: ../../doc_src/language.rst:817
msgid ""
"A ``command substitution`` is an expansion that uses the *output* of a "
"command as the arguments to another. For example::"
msgstr "「コマンド置換」とは、あるコマンドの「出力」を別のコマンドの引数として利用する展開機能のことです。例えば以下のようになります::"

#: ../../doc_src/language.rst:821
msgid ""
"This executes the :doc:`pwd <cmds/pwd>` command, takes its output (more "
"specifically what it wrote to the standard output \"stdout\" stream) and "
"uses it as arguments to :doc:`echo <cmds/echo>`. So the inner command "
"(the ``pwd``) is run first and has to complete before the outer command "
"can even be started."
msgstr ""
"これは :doc:`pwd <cmds/pwd>` "
"コマンドを実行し、その出力(より具体的には標準出力「stdout」ストリームに書き込まれた内容)をキャプチャして、 :doc:`echo "
"<cmds/echo>` "
"の引数として使用します。そのため、内側のコマンド(``pwd``)が先に実行され、それが完了してから外側のコマンドが開始されます。"

#: ../../doc_src/language.rst:823
msgid ""
"If the inner command prints multiple lines, fish will use each separate "
"line as a separate argument to the outer command. Unlike other shells, "
"the value of ``$IFS`` is not used [#]_, fish splits on newlines."
msgstr ""
"内側のコマンドが複数行を出力する場合、fishは各行を個別の引数として外側のコマンドに渡します。他のシェルとは異なり、 ``$IFS`` "
"の値は使用されず [#]_、fishは改行で分割を行います。"

#: ../../doc_src/language.rst:825
msgid "Command substitutions can also be double-quoted::"
msgstr "コマンド置換を二重引用符で囲むこともできます::"

#: ../../doc_src/language.rst:829
msgid ""
"When using double quotes, the command output is not split up by lines, "
"but trailing empty lines are still removed."
msgstr "二重引用符を使用する場合、コマンド出力は行ごとに分割されませんが、末尾の空行は削除されます。"

#: ../../doc_src/language.rst:831
msgid ""
"If the output is piped to :doc:`string split or string split0 <cmds"
"/string-split>` as the last step, those splits are used as they appear "
"instead of splitting lines."
msgstr ""
"出力が最後のステップとして :doc:`string split または string split0 <cmds/string-split>` "
"にパイプで渡された場合、行分割の代わりとして、それらによる分割結果がそのまま使用されます。"

#: ../../doc_src/language.rst:833
msgid ""
"Fish also allows spelling command substitutions without the dollar, like "
"``echo (pwd)``. This variant will not be expanded in double-quotes "
"(``echo \"(pwd)\"`` will print ``(pwd)``)."
msgstr ""
"fishでは、 ``echo (pwd)`` "
"のようにドル記号なしでコマンド置換を記述することも可能です。この形式は二重引用符内では展開されません(``echo \"(pwd)\"`` は "
"``(pwd)`` と表示されます)。"

#: ../../doc_src/language.rst:835
msgid ""
"The exit status of the last run command substitution is available in the "
":ref:`status <variables-status>` variable if the substitution happens in "
"the context of a :doc:`set <cmds/set>` command (so ``if set -l "
"(something)`` checks if ``something`` returned true)."
msgstr ""
"置換が :doc:`set <cmds/set>` コマンドのコンテキスト内で行われた場合、最後に実行されたコマンド置換の終了ステータスを "
":ref:`status <variables-status>` 変数で利用できます(例： ``if set -l (something)`` は"
" ``something`` が真を返したかどうかを判定します)。"

#: ../../doc_src/language.rst:837
msgid ""
"To use only some lines of the output, refer to :ref:`slices <expand-"
"slices>`."
msgstr "出力の特定の行のみを使用するには、 :ref:`スライス <expand-slices>` を参照してください。"

#: ../../doc_src/language.rst:855
msgid ""
"Sometimes you want to pass the output of a command to another command "
"that only accepts files. If it's just one file, you can usually pass it "
"via a pipe, like::"
msgstr "あるコマンドの出力を、ファイルのみを受け付ける別のコマンドに渡したい場合があります。対象が1つのファイルだけであれば、通常は以下のようにパイプ経由で渡すことができます::"

#: ../../doc_src/language.rst:859
msgid ""
"but if you need multiple or the command doesn't read from standard input,"
" \"process substitution\" is useful. Other shells allow this via ``foo "
"<(bar) <(baz)``, and fish uses the :doc:`psub <cmds/psub>` command::"
msgstr ""
"しかし、複数の出力を渡す必要がある場合や、コマンドが標準入力から読み込まない場合は、「プロセス展開」が便利です。他のシェルでは ``foo "
"<(bar) <(baz)`` のような構文が使われますが、fishでは :doc:`psub <cmds/psub>` コマンドを使用します::"

#: ../../doc_src/language.rst:864
msgid ""
"This creates a temporary file, stores the output of the command in that "
"file and prints the filename, so it is given to the outer command."
msgstr "これは一時ファイルを作成し、コマンドの出力をそのファイルに保存してファイル名を出力します。これにより、外側のコマンドにそのファイル名が渡されます。"

#: ../../doc_src/language.rst:866
msgid ""
"Fish has a default limit of 1 GiB on the data it will read in a command "
"substitution. If that limit is reached the command (all of it, not just "
"the command substitution - the outer command won't be executed at all) "
"fails and ``$status`` is set to 122. This is so command substitutions "
"can't cause the system to go out of memory, because typically your "
"operating system has a much lower limit, so reading more than that would "
"be useless and harmful. This limit can be adjusted with the "
"``fish_read_limit`` variable (`0` meaning no limit). This limit also "
"affects the :doc:`read <cmds/read>` command."
msgstr ""
"fishには、コマンド置換で読み込むデータ量に対してデフォルトで1GiBの制限があります。この制限に達すると、コマンド(コマンド置換だけでなく、外側のコマンドも一切実行されません)は失敗し、"
" ``$status`` "
"に122が設定されます。これは、コマンド置換によってシステムがメモリ不足に陥るのを防ぐためのものです。通常、オペレーティングシステムの制限はこれよりもはるかに低いため、それ以上のデータを読み込むことは無益で有害です。この制限は"
" ``fish_read_limit`` 変数で調整可能です(`0` は無制限を意味します)。この制限は :doc:`read "
"<cmds/read>` コマンドにも影響します。"

#: ../../doc_src/language.rst:868
msgid ""
"One exception: Setting ``$IFS`` to empty will disable line splitting. "
"This is deprecated, use :doc:`string split <cmds/string-split>` instead."
msgstr ""
"例外が1つあります。 ``$IFS`` を空に設定すると、行分割が無効になります。これは非推奨ですので、代わりに :doc:`string "
"split <cmds/string-split>` を使用してください。"

#: ../../doc_src/language.rst:873
msgid "Brace expansion"
msgstr "ブレース展開"

#: ../../doc_src/language.rst:875
msgid ""
"Curly braces can be used to write comma-separated lists. They will be "
"expanded with each element becoming a new parameter, with the surrounding"
" string attached. This is useful to save on typing, and to separate a "
"variable name from surrounding text."
msgstr "波括弧(中括弧)を使用して、カンマ区切りのリストを記述できます。これらは展開され、各要素が周囲の文字列を付加した新しいパラメータとなります。これはタイピングの手間を省いたり、変数名と周囲のテキストを区別したりするのに便利です。"

#: ../../doc_src/language.rst:892
msgid ""
"If there is no \",\" or variable expansion between the curly braces, they"
" will not be expanded::"
msgstr "波括弧の中に「,」や変数展開が含まれていない場合、それらは展開されません::"

#: ../../doc_src/language.rst:902
msgid ""
"If after expansion there is nothing between the braces, the argument will"
" be removed (see :ref:`the Combining Lists <cartesian-product>` "
"section)::"
msgstr ""
"展開の結果、ブレースの中に何も残らない場合、その引数は削除されます(詳細は :ref:`リストの結合 <cartesian-product>` "
"セクションを参照してください)::"

#: ../../doc_src/language.rst:907
msgid ""
"If there is nothing between a brace and a comma or two commas, it's "
"interpreted as an empty element::"
msgstr "ブレースとカンマの間、あるいは2つのカンマの間に何もない場合は、空の要素として解釈されます::"

#: ../../doc_src/language.rst:912
msgid ""
"To use a \",\" as an element, :ref:`quote <quotes>` or :ref:`escape "
"<escapes>` it."
msgstr "「,」を要素として使用するには、 :ref:`引用符で囲む <quotes>` か :ref:`エスケープ <escapes>` してください。"

#: ../../doc_src/language.rst:914
msgid ""
"The very first character of a command token is never interpreted as "
"expanding brace, because it's the beginning of a :doc:`compound statement"
" <cmds/begin>`::"
msgstr ""
"コマンドトークンの最初の文字は、ブレース展開として解釈されることはありません。なぜなら、それは :doc:`複合文 <cmds/begin>` "
"の開始を意味するためです::"

#: ../../doc_src/language.rst:923
msgid "Combining lists"
msgstr ""

#: ../../doc_src/language.rst:925
msgid "Fish expands lists like :ref:`brace expansions <expand-brace>`::"
msgstr ""

#: ../../doc_src/language.rst:940
msgid "Any string attached to a list will be concatenated to each element."
msgstr ""

#: ../../doc_src/language.rst:942
msgid ""
"Two lists will be expanded in all combinations  - every element of the "
"first with every element of the second::"
msgstr ""

#: ../../doc_src/language.rst:948
msgid ""
"A result of this is that, if a list has no elements, this combines the "
"string with no elements, which means the entire token is removed!"
msgstr ""

#: ../../doc_src/language.rst:956
msgid ""
"This can be quite useful. For example, if you want to go through all the "
"files in all the directories in :envvar:`PATH`, use ::"
msgstr ""

#: ../../doc_src/language.rst:961
msgid ""
"Because :envvar:`PATH` is a list, this expands to all the files in all "
"the directories in it. And if there are no directories in :envvar:`PATH`,"
" the right answer here is to expand to no files."
msgstr ""

#: ../../doc_src/language.rst:963
msgid ""
"Sometimes this may be unwanted, especially that tokens can disappear "
"after expansion. In those cases, you should double-quote variables - "
"``echo \"$c\"word``."
msgstr ""

#: ../../doc_src/language.rst:965
msgid ""
"This also happens after :ref:`command substitution <expand-command-"
"substitution>`. To avoid tokens disappearing there, make the inner "
"command return a trailing newline, or double-quote it::"
msgstr ""

#: ../../doc_src/language.rst:984
msgid "Slices"
msgstr ""

#: ../../doc_src/language.rst:986
msgid ""
"Sometimes it's necessary to access only some of the elements of a "
":ref:`list <variables-lists>` (all fish variables are lists), or some of "
"the lines a :ref:`command substitution <expand-command-substitution>` "
"outputs. Both are possible in fish by writing a set of indices in "
"brackets, like::"
msgstr ""

#: ../../doc_src/language.rst:997
msgid ""
"In index brackets, fish understands ranges written like ``a..b`` ('a' and"
" 'b' being indices). They are expanded into a sequence of indices from a "
"to b (so ``a a+1 a+2 ... b``), going up if b is larger and going down if "
"a is larger. Negative indices can also be used - they are taken from the "
"end of the list, so ``-1`` is the last element, and ``-2`` the one before"
" it. If an index doesn't exist the range is clamped to the next possible "
"index."
msgstr ""

#: ../../doc_src/language.rst:999
msgid ""
"If a list has 5 elements the indices go from 1 to 5, so a range of "
"``2..16`` will only go from element 2 to element 5."
msgstr ""

#: ../../doc_src/language.rst:1001
msgid ""
"If the end is negative the range always goes up, so ``2..-2`` will go "
"from element 2 to 4, and ``2..-16`` won't go anywhere because there is no"
" way to go from the second element to one that doesn't exist, while going"
" up. If the start is negative the range always goes down, so ``-2..1`` "
"will go from element 4 to 1, and ``-16..2`` won't go anywhere because "
"there is no way to go from an element that doesn't exist to the second "
"element, while going down."
msgstr ""

#: ../../doc_src/language.rst:1004
msgid ""
"A missing starting index in a range defaults to 1. This is allowed if the"
" range is the first index expression of the sequence. Similarly, a "
"missing ending index, defaulting to -1 is allowed for the last index in "
"the sequence."
msgstr ""

#: ../../doc_src/language.rst:1006
msgid "Multiple ranges are also possible, separated with a space."
msgstr ""

#: ../../doc_src/language.rst:1008
msgid "Some examples::"
msgstr ""

#: ../../doc_src/language.rst:1038
msgid "The same works when setting or expanding variables::"
msgstr ""

#: ../../doc_src/language.rst:1050
msgid "Variables can be used as indices for expansion of variables, like so::"
msgstr ""

#: ../../doc_src/language.rst:1056
msgid ""
"However using variables as indices for command substitution is currently "
"not supported, so::"
msgstr ""

#: ../../doc_src/language.rst:1063
msgid ""
"When using indirect variable expansion with multiple ``$`` (``$$name``), "
"you have to give all indices up to the variable you want to slice::"
msgstr ""

#: ../../doc_src/language.rst:1075
msgid "Home directory expansion"
msgstr ""

#: ../../doc_src/language.rst:1077
msgid ""
"The ``~`` (tilde) character at the beginning of a parameter, followed by "
"a username, is expanded into the home directory of the specified user. A "
"lone ``~``, or a ``~`` followed by a slash, is expanded into the home "
"directory of the process owner::"
msgstr ""

#: ../../doc_src/language.rst:1084
msgid "Combining different expansions"
msgstr ""

#: ../../doc_src/language.rst:1086
msgid ""
"All of the above expansions can be combined. If several expansions result"
" in more than one parameter, all possible combinations are created."
msgstr ""

#: ../../doc_src/language.rst:1088
msgid ""
"When combining multiple parameter expansions, expansions are performed in"
" the following order:"
msgstr ""

#: ../../doc_src/language.rst:1090
msgid "Command substitutions"
msgstr ""

#: ../../doc_src/language.rst:1091
msgid "Variable expansions"
msgstr ""

#: ../../doc_src/language.rst:1092
msgid "Bracket expansion"
msgstr ""

#: ../../doc_src/language.rst:1093
msgid "Wildcard expansion"
msgstr ""

#: ../../doc_src/language.rst:1095
msgid ""
"Expansions are performed from right to left, nested bracket expansions "
"and command substitutions are performed from the inside and out."
msgstr ""

#: ../../doc_src/language.rst:1097 ../../doc_src/language.rst:1133
#: ../../doc_src/language.rst:1200 ../../doc_src/language.rst:2084
msgid "Example:"
msgstr "例:"

#: ../../doc_src/language.rst:1099
#, python-brace-format
msgid ""
"If the current directory contains the files 'foo' and 'bar', the command "
"``echo a(ls){1,2,3}`` will output ``abar1 abar2 abar3 afoo1 afoo2 "
"afoo3``."
msgstr ""

#: ../../doc_src/language.rst:1102
msgid "Table Of Operators"
msgstr ""

#: ../../doc_src/language.rst:1104
msgid ""
"Putting it together, here is a quick reference to fish's operators, all "
"of the special symbols it uses:"
msgstr ""

#: ../../doc_src/language.rst:1107
msgid "Symbol"
msgstr ""

#: ../../doc_src/language.rst:1107
msgid "Meaning"
msgstr ""

#: ../../doc_src/language.rst:1107
msgid "Example"
msgstr ""

#: ../../doc_src/language.rst:1109
msgid "``$``"
msgstr ""

#: ../../doc_src/language.rst:1109
msgid ":ref:`Variable expansion <expand-variable>`"
msgstr ""

#: ../../doc_src/language.rst:1109
msgid "``echo $foo``"
msgstr ""

#: ../../doc_src/language.rst:1110
msgid "``$()`` and ``()``"
msgstr ""

#: ../../doc_src/language.rst:1110
msgid ":ref:`Command substitution <expand-command-substitution>`"
msgstr ""

#: ../../doc_src/language.rst:1110
msgid "``cat (grep foo bar)`` or ``cat $(grep foo bar)``"
msgstr ""

#: ../../doc_src/language.rst:1111
msgid "``<`` and ``>``"
msgstr ""

#: ../../doc_src/language.rst:1111
msgid ":ref:`Redirection <redirects>`, like ``command > file``"
msgstr ""

#: ../../doc_src/language.rst:1111
msgid "``git shortlog -nse . > authors``"
msgstr ""

#: ../../doc_src/language.rst:1112
msgid "``|``"
msgstr ""

#: ../../doc_src/language.rst:1112
msgid ":ref:`Pipe <pipes>`, connect two or more commands"
msgstr ""

#: ../../doc_src/language.rst:1112
msgid "``foo | grep bar | grep baz``"
msgstr ""

#: ../../doc_src/language.rst:1113
msgid "``;``"
msgstr ""

#: ../../doc_src/language.rst:1113
msgid "End of the command, instead of a newline"
msgstr ""

#: ../../doc_src/language.rst:1113
msgid "``command1; command2``"
msgstr ""

#: ../../doc_src/language.rst:1114
msgid "``&``"
msgstr ""

#: ../../doc_src/language.rst:1114
msgid ":ref:`Backgrounding <syntax-job-control>`"
msgstr ""

#: ../../doc_src/language.rst:1114
msgid "``sleep 5m &``"
msgstr ""

#: ../../doc_src/language.rst:1115
#, python-brace-format
msgid "``{}``"
msgstr ""

#: ../../doc_src/language.rst:1115
msgid ":ref:`Brace expansion <expand-brace>`"
msgstr ""

#: ../../doc_src/language.rst:1115
#, python-brace-format
msgid "``ls {/usr,}/bin``"
msgstr ""

#: ../../doc_src/language.rst:1116
msgid "``&&`` and ``||``"
msgstr ""

#: ../../doc_src/language.rst:1116
msgid ":ref:`Combiners <syntax-combiners>`"
msgstr ""

#: ../../doc_src/language.rst:1116
msgid "``mkdir foo && cd foo`` or ``rm foo || exit``"
msgstr ""

#: ../../doc_src/language.rst:1117
msgid "``*`` and ``**``"
msgstr ""

#: ../../doc_src/language.rst:1117
msgid ":ref:`Wildcards <expand-wildcard>`"
msgstr ""

#: ../../doc_src/language.rst:1117
msgid "``cat *.fish`` or ``count **.jpg``"
msgstr ""

#: ../../doc_src/language.rst:1118
msgid "``\\\\``"
msgstr ""

#: ../../doc_src/language.rst:1118
msgid ":ref:`Escaping <escapes>`"
msgstr ""

#: ../../doc_src/language.rst:1118
msgid "``echo foo\\nbar`` or ``echo \\$foo``"
msgstr ""

#: ../../doc_src/language.rst:1119
msgid "``''`` and ``\"\"``"
msgstr ""

#: ../../doc_src/language.rst:1119
msgid ":ref:`Quoting <quotes>`"
msgstr ""

#: ../../doc_src/language.rst:1119
msgid "``rm \"file with spaces\"`` or ``echo '$foo'``"
msgstr ""

#: ../../doc_src/language.rst:1120
msgid "``~``"
msgstr ""

#: ../../doc_src/language.rst:1120
msgid ":ref:`Home directory expansion <expand-home>`"
msgstr ""

#: ../../doc_src/language.rst:1120
msgid "``ls ~/`` or ``ls ~root/``"
msgstr ""

#: ../../doc_src/language.rst:1121
msgid "``#``"
msgstr ""

#: ../../doc_src/language.rst:1121
msgid ":ref:`Comments`"
msgstr ""

#: ../../doc_src/language.rst:1121
msgid "``echo Hello # this isn't printed``"
msgstr ""

#: ../../doc_src/language.rst:1127
msgid "Shell variables"
msgstr "シェル変数"

#: ../../doc_src/language.rst:1129
msgid ""
"Variables are a way to save data and pass it around. They can be used "
"just by the shell, or they can be \":ref:`exported <variables-export>`\","
" so that a copy of the variable is available to any external command the "
"shell starts. An exported variable is referred to as an \"environment "
"variable\"."
msgstr ""
"変数は、データを保存して受け渡すための手段です。変数はシェル内だけで使用することもできますし、 「 :ref:`エクスポート "
"<variables-export>` "
"」して、シェルが起動するあらゆる外部コマンドでそのコピーを利用できるようにすることもできます。エクスポートされた変数は「環境変数」と呼ばれます。"

#: ../../doc_src/language.rst:1131
msgid ""
"To set a variable value, use the :doc:`set <cmds/set>` command. A "
"variable name can not be empty and can contain only letters, digits, and "
"underscores. It may begin and end with any of those characters."
msgstr ""
"変数の値を設定するには、 :doc:`set <cmds/set>` "
"コマンドを使用します。変数名を空にすることはできず、使用できるのは英文字、数字、およびアンダースコアのみです。変数名はこれらのどの文字から始めても、どの文字で終わっても構いません。"

#: ../../doc_src/language.rst:1135
msgid ""
"To set the variable ``smurf_color`` to the value ``blue``, use the "
"command ``set smurf_color blue``."
msgstr ""
"変数 ``smurf_color`` の値を ``blue`` に設定するには、 ``set smurf_color blue`` "
"というコマンドを使用します。"

#: ../../doc_src/language.rst:1137
msgid ""
"After a variable has been set, you can use the value of a variable in the"
" shell through :ref:`variable expansion <expand-variable>`."
msgstr "変数が設定された後は、 :ref:`変数展開 <expand-variable>` を通じてシェル内でその変数の値を使用できるようになります。"

#: ../../doc_src/language.rst:1146
msgid "So you set a variable with ``set``, and use it with a ``$`` and the name."
msgstr "このように、 ``set`` で変数を設定し、 ``$`` と変数名を使ってその変数を使用します。"

#: ../../doc_src/language.rst:1151
msgid "Variable Scope"
msgstr "変数のスコープ"

#: ../../doc_src/language.rst:1153
msgid ""
"All variables in fish have a scope. For example they can be global or "
"local to a function or block::"
msgstr "fishのすべての変数にはスコープがあります。例えば、変数はグローバルにすることもできますし、関数やブロックに対してローカルにすることもできます::"

#: ../../doc_src/language.rst:1183
msgid ""
"There are four kinds of variable scopes in fish: universal, global, "
"function and local variables."
msgstr "fishには4種類の変数スコープがあります。ユニバーサル変数、グローバル変数、関数変数、そしてローカル変数です。"

#: ../../doc_src/language.rst:1185
msgid ""
"Universal variables are shared between all fish sessions a user is "
"running on one computer. They are stored on disk and persist even after "
"reboot."
msgstr "ユニバーサル変数は、1台のコンピュータ上でユーザーが実行しているすべてのfishセッション間で共有されます。これらはディスクに保存され、再起動後も保持されます。"

#: ../../doc_src/language.rst:1186
msgid ""
"Global variables are specific to the current fish session. They can be "
"erased by explicitly requesting ``set -e``."
msgstr "グローバル変数は、現在のfishセッションに固有のものです。 ``set -e`` を明示的に実行することで消去できます。"

#: ../../doc_src/language.rst:1187
msgid ""
"Function variables are specific to the currently executing function. They"
" are erased (\"go out of scope\") when the current function ends. Outside"
" of a function, they don't go out of scope."
msgstr "関数変数は、現在実行中の関数に固有のものです。現在の関数が終了すると消去(「スコープ外になる」)されます。関数の外側では、これらがスコープ外になることはありません。"

#: ../../doc_src/language.rst:1188
msgid ""
"Local variables are specific to the current block of commands, and "
"automatically erased when a specific block goes out of scope. A block of "
"commands is a series of commands that begins with one of the commands "
"``for``, ``while`` , ``if``, ``function``, ``begin`` or ``switch``, and "
"ends with the command ``end``. Outside of a block, this is the same as "
"the function scope."
msgstr ""
"ローカル変数は、現在のコマンドブロックに固有のものであり、特定のブロックがスコープ外になると自動的に消去されます。コマンドブロックとは、 "
"``for``、``while``、 ``if``、 ``function``、 ``begin``、 ``switch`` "
"のいずれかのコマンドで始まり、 ``end`` "
"コマンドで終わる一連のコマンドを指します。ブロックの外側では、これは関数スコープと同じ扱いになります。"

#: ../../doc_src/language.rst:1190
msgid ""
"Variables can be explicitly set to be universal with the ``-U`` or "
"``--universal`` switch, global with ``-g`` or ``--global``, function-"
"scoped with ``-f`` or ``--function`` and local to the current block with "
"``-l`` or ``--local``.  The scoping rules when creating or updating a "
"variable are:"
msgstr ""
"変数は、 ``-U`` または ``--universal`` スイッチでユニバーサルに、 ``-g`` または ``--global`` "
"でグローバルに、 ``-f`` または ``--function`` で関数スコープに、そして ``-l`` または ``--local`` "
"で現在のブロックに対してローカルに、それぞれ明示的に設定できます。変数の作成または更新時のスコープ規則は以下の通りです。"

#: ../../doc_src/language.rst:1192
msgid ""
"When a scope is explicitly given, it will be used. If a variable of the "
"same name exists in a different scope, that variable will not be changed."
msgstr "スコープが明示的に指定された場合は、そのスコープが使用されます。別のスコープに同名の変数が存在していても、その変数は変更されません。"

#: ../../doc_src/language.rst:1194
msgid ""
"When no scope is given, but a variable of that name exists, the variable "
"of the smallest scope will be modified. The scope will not be changed."
msgstr "スコープが指定されていないが同名の変数が存在する場合、最も小さいスコープの変数が修正されます。その際、スコープ自体は変更されません。"

#: ../../doc_src/language.rst:1196
msgid ""
"When no scope is given and no variable of that name exists, the variable "
"is created in function scope if inside a function, or global scope if no "
"function is executing."
msgstr "スコープが指定されておらず、同名の変数も存在しない場合、関数内であれば関数スコープに、関数が実行されていなければグローバルスコープに変数が作成されます。"

#: ../../doc_src/language.rst:1198
msgid ""
"There can be many variables with the same name, but different scopes. "
"When you :ref:`use a variable <expand-variable>`, the smallest scoped "
"variable of that name will be used. If a local variable exists, it will "
"be used instead of the global or universal variable of the same name."
msgstr ""
"同じ名前で異なるスコープを持つ変数が複数存在することがあります。 :ref:`変数を使用 <expand-variable>` "
"する際、その名前を持つ最も小さいスコープの変数が使用されます。もしローカル変数が存在する場合、同名のグローバル変数やユニバーサル変数よりも優先して使用されます。"

#: ../../doc_src/language.rst:1202
msgid "There are a few possible uses for different scopes."
msgstr "異なるスコープには、いくつかの使い道があります。"

#: ../../doc_src/language.rst:1204
msgid "Typically inside functions you should use local scope::"
msgstr "通常、関数内部ではローカルスコープを使用すべきです::"

#: ../../doc_src/language.rst:1223
msgid ""
"If you want to set something in config.fish, or set something in a "
"function and have it available for the rest of the session, global scope "
"is a good choice::"
msgstr "config.fish内で何かを設定する場合や、関数内で設定したものをそのセッションの残りの間ずっと利用可能にしたい場合は、グローバルスコープが良い選択肢です::"

#: ../../doc_src/language.rst:1238
msgid "Here is an example of local vs function-scoped variables::"
msgstr "以下は、ローカル変数と関数スコープ変数の比較例です::"

#: ../../doc_src/language.rst:1258
msgid "When a function calls another, local variables aren't visible::"
msgstr "ある関数が別の関数を呼び出す際、ローカル変数は参照できません::"

#: ../../doc_src/language.rst:1276
msgid ""
"When in doubt, use function-scoped variables. When you need to make a "
"variable accessible everywhere, make it global. When you need to "
"persistently store configuration, make it universal. When you want to use"
" a variable only in a short block, make it local."
msgstr "迷ったときは、関数スコープの変数を使用してください。変数をどこからでもアクセス可能にする必要があるときはグローバルに、設定を永続的に保存する必要があるときはユニバーサルにします。短いブロック内だけで変数を使用したいときは、ローカルにしてください。"

#: ../../doc_src/language.rst:1281
msgid "Overriding variables for a single command"
msgstr "単一コマンドでの変数の一時的な上書き"

#: ../../doc_src/language.rst:1283
msgid ""
"If you want to override a variable for a single command, you can use "
"\"var=val\" statements before the command::"
msgstr "単一のコマンドに対して変数を一時的に上書きしたい場合は、コマンドの前に \"var=val\" ステートメントを使用できます::"

#: ../../doc_src/language.rst:1289
msgid ""
"Unlike other shells, fish will first set the variable and then perform "
"other expansions on the line, so::"
msgstr "他のシェルとは異なり、fishはまず変数を設定してから、その行の他の展開処理を行います。そのため、以下のようになります::"

#: ../../doc_src/language.rst:1295
msgid "Multiple elements can be given in a :ref:`brace expansion<expand-brace>`::"
msgstr ":ref:`ブレース展開 <expand-brace>` を使って、複数の要素を指定することもできます::"

#: ../../doc_src/language.rst:1300
msgid "Or with a :ref:`glob <expand-wildcard>`::"
msgstr "あるいは、 :ref:`グロブ <expand-wildcard>` を使った例です::"

#: ../../doc_src/language.rst:1306
msgid ""
"Unlike other shells, this does *not* inhibit any lookup (aliases or "
"similar). Calling a command after setting a variable override will result"
" in the exact same command being run."
msgstr ""
"他のシェルとは異なり、これによってルックアップ(エイリアスなど)が抑制されることは *ありません* "
"。変数の上書きを設定した後にコマンドを呼び出すと、設定前と全く同じコマンドが実行されます。"

#: ../../doc_src/language.rst:1308
msgid "This syntax is supported since fish 3.1."
msgstr "この構文は fish 3.1 以降でサポートされています。"

#: ../../doc_src/language.rst:1313
msgid "Universal Variables"
msgstr "ユニバーサル変数"

#: ../../doc_src/language.rst:1315
msgid ""
"Universal variables are variables that are shared between all the user's "
"fish sessions on the computer. All changes to universal variables are "
"persistent and instantly propagated across fish sessions."
msgstr ""
"ユニバーサル変数は、そのコンピュータ上のユーザーのすべての fish "
"セッション間で共有される変数です。ユニバーサル変数へのすべての変更は永続的であり、即座に他の fish セッションへ伝搬されます。"

#: ../../doc_src/language.rst:1318
msgid ""
":ref:`Universal variables <variables-universal>` are stored in the file "
"``.config/fish/fish_variables``. Do not edit this file directly, as your "
"edits may be overwritten. Edit the variables through fish scripts or by "
"using fish interactively instead."
msgstr ""
":ref:`ユニバーサル変数 <variables-universal>` は、 ``.config/fish/fish_variables`` "
"ファイルに保存されます。編集内容が上書きされる可能性があるため、このファイルを直接編集しないでください。代わりに、fish "
"スクリプトを通じて、または fish を対話的に使用して変数を編集してください。"

#: ../../doc_src/language.rst:1320
msgid ""
"Do not append to universal variables in :ref:`config.fish "
"<configuration>`, because these variables will then get longer with each "
"new shell instance. Instead, set them once at the command line."
msgstr ""
":ref:`config.fish <configuration>` "
"内でユニバーサル変数に要素を追加(append)しないでください。新しいシェルが起動するたびに変数が長くなってしまうためです。代わりに、コマンドラインで一度だけ設定するようにしてください。"

#: ../../doc_src/language.rst:1325
msgid "Exporting variables"
msgstr "変数のエクスポート"

#: ../../doc_src/language.rst:1327
msgid ""
"Variables in fish can be exported, so they will be inherited by any "
"commands started by fish. In particular, this is necessary for variables "
"used to configure external commands like ``PAGER`` or ``GOPATH``, but "
"also for variables that contain general system settings like ``PATH`` or "
"``LANGUAGE``. If an external command needs to know a variable, it needs "
"to be exported. Exported variables are also often called \"environment "
"variables\"."
msgstr ""
"fish の変数はエクスポートすることができ、それにより fish が起動するあらゆるコマンドに継承されます。特に、 ``PAGER`` や "
"``GOPATH`` のような外部コマンドの設定に使用される変数や、 ``PATH`` や ``LANGUAGE`` "
"のような一般的なシステム設定を含む変数にはこれが必要です。外部コマンドが変数を参照する必要がある場合、その変数はエクスポートされていなければなりません。エクスポートされた変数は、しばしば「環境変数」とも呼ばれます。"

#: ../../doc_src/language.rst:1329
msgid ""
"This also applies to fish - when it starts up, it receives environment "
"variables from its parent (usually the terminal). These typically include"
" system configuration like :envvar:`PATH` and :ref:`locale variables "
"<variables-locale>`."
msgstr ""
"これは fish 自体にも当てはまります。fish は起動時に、親プロセス(通常はターミナル)から環境変数を受け取ります。これらには通常、 "
":envvar:`PATH` や :ref:`ロケール変数 <variables-locale>` などのシステム設定が含まれます。"

#: ../../doc_src/language.rst:1331
msgid ""
"Variables can be explicitly set to be exported with the ``-x`` or "
"``--export`` switch, or not exported with the ``-u`` or ``--unexport`` "
"switch.  The exporting rules when setting a variable are similar to the "
"scoping rules for variables - when an option is passed it is respected, "
"otherwise the variable's existing state is used. If no option is passed "
"and the variable didn't exist yet it is not exported."
msgstr ""
"変数は、 ``-x`` または ``--export`` スイッチで明示的にエクスポートするように設定でき、 ``-u`` または "
"``--unexport`` "
"スイッチでエクスポートしないように設定できます。変数を設定する際のエクスポート規則は、変数のスコーピング規則と似ています。オプションが渡された場合はそれが尊重され、そうでない場合は変数の既存の状態が維持されます。オプションが渡されず、かつ変数がまだ存在していなかった場合、その変数はエクスポートされません。"

#: ../../doc_src/language.rst:1333
msgid ""
"As a naming convention, exported variables are in uppercase and "
"unexported variables are in lowercase."
msgstr "命名規則として、エクスポートされた変数は大文字で、エクスポートされていない変数は小文字で記述します。"

#: ../../doc_src/language.rst:1344
msgid ""
"Note: Exporting is not a :ref:`scope <variables-scope>`, but an "
"additional state. It typically makes sense to make exported variables "
"global as well, but local-exported variables can be useful if you need "
"something more specific than :ref:`Overrides <variables-override>`. They "
"are *copied* to functions so the function can't alter them outside, and "
"still available to commands. Global variables are accessible to functions"
" whether they are exported or not."
msgstr ""
"Note: エクスポートは :ref:`スコープ <variables-scope>` "
"ではなく、追加の状態です。通常、エクスポートされた変数はグローバルにもするのが理にかなっていますが、 :ref:`変数の一時的な上書き "
"<variables-override>` "
"よりも詳細な制御が必要な場合には、ローカルでエクスポートされた変数が役立ちます。これらは関数に「コピー」されるため、関数が外部の値を変更することはできませんが、コマンドからは引き続き利用可能です。グローバル変数は、エクスポートされているかどうかにかかわらず関数からアクセスできます。"

#: ../../doc_src/language.rst:1349
msgid "Lists"
msgstr "リスト"

#: ../../doc_src/language.rst:1351
msgid ""
"Fish can store a list (or an \"array\" if you wish) of multiple strings "
"inside of a variable::"
msgstr "fishでは、変数の中に複数の文字列のリスト(お好みであれば「配列」)を格納できます::"

#: ../../doc_src/language.rst:1359
msgid ""
"To access one element of a list, use the index of the element inside of "
"square brackets, like this::"
msgstr "リストの1つの要素にアクセスするには、次のように角括弧の中に要素のインデックスを指定します::"

#: ../../doc_src/language.rst:1363
msgid ""
"List indices start at 1 in fish, not 0 like in other languages. This is "
"because it requires less subtracting of 1 and many common Unix tools like"
" ``seq`` work better with it (``seq 5`` prints 1 to 5, not 0 to 5). An "
"invalid index is silently ignored resulting in no value (not even an "
"empty string, no argument at all)."
msgstr ""
"fishのリストのインデックスは、他の言語のように0からではなく、1から始まります。これは「1を引く」手間を減らすためであり、 ``seq`` "
"のような多くの一般的なUnixツールとの相性が良いためです(``seq 5`` "
"は0から5ではなく、1から5を出力します)。無効なインデックスは黙って無視され、値なし(空の文字列ですらなく、引数自体が存在しない状態)になります。"

#: ../../doc_src/language.rst:1365
msgid ""
"If you don't use any brackets, all the elements of the list will be "
"passed to the command as separate items. This means you can iterate over "
"a list with ``for``::"
msgstr "括弧を使用しない場合、リストのすべての要素が個別のアイテムとしてコマンドに渡されます。つまり、 ``for`` を使ってリストを反復処理できます::"

#: ../../doc_src/language.rst:1371
msgid ""
"This goes over every directory in :envvar:`PATH` separately and prints a "
"line saying it is in the path."
msgstr "これは :envvar:`PATH` 内の各ディレクトリを個別に巡回し、それがパスに含まれていることを示す行を表示します。"

#: ../../doc_src/language.rst:1373
msgid ""
"To create a variable ``smurf``, containing the items ``blue`` and "
"``small``, write::"
msgstr "``blue`` と ``small`` というアイテムを含む変数 ``smurf`` を作成するには、次のように記述します::"

#: ../../doc_src/language.rst:1377
msgid "It is also possible to set or erase individual elements of a list::"
msgstr "リストの個々の要素を設定したり消去したりすることも可能です::"

#: ../../doc_src/language.rst:1391
msgid ""
"If you specify a negative index when expanding or assigning to a list "
"variable, the index will be taken from the *end* of the list. For "
"example, the index -1 is the last element of the list::"
msgstr ""
"リスト変数の展開や代入時に負のインデックスを指定すると、インデックスはリストの「末尾」から数えられます。例えば、インデックス -1 "
"はリストの最後の要素を指します::"

#: ../../doc_src/language.rst:1406
msgid ""
"As you see, you can use a range of indices, see :ref:`slices <expand-"
"slices>` for details."
msgstr "インデックスの範囲を指定することもできます。詳細は :ref:`スライス <expand-slices>` を参照してください。"

#: ../../doc_src/language.rst:1408
msgid ""
"All lists are one-dimensional and can't contain other lists, although it "
"is possible to fake nested lists using dereferencing - see :ref:`variable"
" expansion <expand-variable>`."
msgstr ""
"すべてのリストは一次元であり、他のリストを含めることはできません。ただし、デリファレンスを使用して、入れ子になったリストを模倣することは可能です。詳細は"
" :ref:`変数展開 <expand-variable>` を参照してください。"

#: ../../doc_src/language.rst:1410
msgid ""
"When a list is exported as an environment variable, it is either space or"
" colon delimited, depending on whether it is a :ref:`path variable "
"<variables-path>`::"
msgstr ""
"リストが環境変数としてエクスポートされる際、それが :ref:`パス変数 <variables-path>` "
"であるかどうかに応じて、スペースまたはコロンで区切られます::"

#: ../../doc_src/language.rst:1418
msgid ""
"Fish automatically creates lists from all environment variables whose "
"name ends in ``PATH`` (like :envvar:`PATH`, :envvar:`CDPATH` or "
":envvar:`MANPATH`), by splitting them on colons. Other variables are not "
"automatically split."
msgstr ""
"fishは、名前が ``PATH`` で終わるすべての環境変数( :envvar:`PATH`、 :envvar:`CDPATH`、 "
":envvar:`MANPATH` など)をコロンで分割し、自動的にリストを作成します。その他の変数は自動的には分割されません。"

#: ../../doc_src/language.rst:1420
msgid ""
"Lists can be inspected with the :doc:`count <cmds/count>` or the "
":doc:`contains <cmds/contains>` commands::"
msgstr ""
"リストの状態は、 :doc:`count <cmds/count>` や :doc:`contains <cmds/contains>` "
"コマンドで確認できます::"

#: ../../doc_src/language.rst:1435
msgid ""
"A nice thing about lists is that they are passed to commands one element "
"as one argument, so once you've set your list, you can pass it::"
msgstr "リストの優れた点は、1つの要素が1つの引数としてコマンドに渡されることです。そのため、一度リストを設定すれば、そのまま渡すことができます::"

#: ../../doc_src/language.rst:1440
msgid ""
"Unlike other shells, fish does not do \"word splitting\" - elements in a "
"list stay as they are, even if they contain spaces or tabs."
msgstr "他のシェルとは異なり、fishは「ワードスプリッティング(単語の分割)」を行いません。リスト内の要素は、スペースやタブを含んでいてもそのままの状態が維持されます。"

#: ../../doc_src/language.rst:1445
msgid "Argument Handling"
msgstr "引数の処理"

#: ../../doc_src/language.rst:1447
msgid ""
"An important list is ``$argv``, which contains the arguments to a "
"function or script. For example::"
msgstr "重要なリストの1つに ``$argv`` があります。これには関数やスクリプトへの引数が格納されます。例を示します::"

#: ../../doc_src/language.rst:1454
msgid ""
"This function takes whatever arguments it gets and prints the first and "
"third::"
msgstr "この関数は、受け取った引数のうち1番目と3番目の引数を出力します::"

#: ../../doc_src/language.rst:1464
msgid ""
"That covers the positional arguments, but commandline tools often get "
"various options and flags, and $argv would contain them intermingled with"
" the positional arguments. Typical unix argument handling allows short "
"options (``-h``, also grouped like in ``ls -lah``), long options "
"(``--help``) and allows those options to take arguments (``--color=auto``"
" or ``--position anywhere`` or ``complete -C\"git \"``) as well as a "
"``--`` separator to signal the end of options. Handling all of these "
"manually is tricky and error-prone."
msgstr ""
"上記は位置引数に関するものですが、コマンドラインツールでは多くの場合、さまざまなオプションやフラグが指定されます。 ``$argv`` "
"にはそれらが位置引数と混ざった状態で格納されます。一般的なUnixの引数処理では、短縮オプション(``-h``、あるいは ``ls -lah`` "
"のようにまとめる形式)やロングオプション(``--help``)が利用でき、さらにそれらのオプションに引数を持たせること(``--color=auto``、"
" ``--position anywhere``、 ``complete -C\"git \"`` "
"など)も可能です。また、オプションの終わりを示す ``--`` "
"セパレータも使われます。これらすべてを手動で処理するのは複雑で、エラーが発生しやすくなります。"

#: ../../doc_src/language.rst:1466
msgid ""
"A more robust approach to option handling is :doc:`argparse "
"<cmds/argparse>`, which checks the defined options and puts them into "
"various variables, leaving only the positional arguments in $argv. Here's"
" a simple example::"
msgstr ""
"オプション処理のより堅牢なアプローチは :doc:`argparse <cmds/argparse>` "
"です。これは定義されたオプションをチェックして別々の変数に格納し、 ``$argv`` には位置引数のみを残します。簡単な例を示します::"

#: ../../doc_src/language.rst:1496
msgid ""
"The options will be *removed* from $argv, so $argv[2] is the second "
"*positional* argument now::"
msgstr "オプションは ``$argv`` から「削除」されるため、この例の ``$argv[2]`` は「2番目の位置引数」を指すようになります::"

#: ../../doc_src/language.rst:1501
msgid ""
"For more information on argparse, like how to handle option arguments, "
"see :doc:`the argparse documentation <cmds/argparse>`."
msgstr ""
"オプション引数の扱い方など、argparseの詳細については :doc:`argparseのドキュメント <cmds/argparse>` "
"を参照してください。"

#: ../../doc_src/language.rst:1506
msgid "PATH variables"
msgstr "パス変数"

#: ../../doc_src/language.rst:1508
msgid ""
"Path variables are a special kind of variable used to support colon-"
"delimited path lists including :envvar:`PATH`, :envvar:`CDPATH`, "
":envvar:`MANPATH`, :envvar:`PYTHONPATH`, :envvar:`LANGUAGE` (for "
":doc:`localization <cmds/_>`) etc. All variables that end in \"PATH\" "
"(case-sensitive) become PATH variables by default."
msgstr ""
"パス変数は、 :envvar:`PATH`、 :envvar:`CDPATH`、 :envvar:`MANPATH`、 "
":envvar:`PYTHONPATH`、 :envvar:`LANGUAGE` ( :doc:`ローカライズ <cmds/_>` "
"用)など、コロン区切りのパスリストをサポートするための特殊な変数です。名前が \"PATH\" "
"(大文字小文字を区別)で終わるすべての変数は、デフォルトでパス変数になります。"

#: ../../doc_src/language.rst:1510
msgid ""
"PATH variables act as normal lists, except they are implicitly joined and"
" split on colons."
msgstr "パス変数は通常のリストとして動作しますが、コロンで暗黙的に結合・分割されるという点が異なります。"

#: ../../doc_src/language.rst:1523
msgid ""
"Path variables will also be exported in the colon form, so ``set -x "
"MYPATH 1 2 3`` will have external commands see it as ``1:2:3``."
msgstr ""
"パス変数はコロン区切りの形式でエクスポートされます。そのため、 ``set -x MYPATH 1 2 3`` を実行すると、外部コマンドからは "
"``1:2:3`` として参照されます。"

#: ../../doc_src/language.rst:1531
msgid ""
"This is for compatibility with other tools. Unix doesn't have variables "
"with multiple elements, the closest thing it has are colon-lists like "
":envvar:`PATH`. For obvious reasons this means no element can contain a "
"``:``."
msgstr ""
"これは他のツールとの互換性を保つためです。Unixには複数の要素を持つ変数は存在せず、それに最も近いものが :envvar:`PATH` "
"のようなコロン区切りのリストです。当然の理由から、各要素の中に ``:`` を含めることはできません。"

#: ../../doc_src/language.rst:1533
msgid ""
"Variables can be marked or unmarked as PATH variables via the ``--path`` "
"and ``--unpath`` options to ``set``."
msgstr ""
"変数は、 ``set`` の ``--path`` および ``--unpath`` "
"オプションを使用して、パス変数としてマークしたり、マークを解除したりできます。"

#: ../../doc_src/language.rst:1538
msgid "Special variables"
msgstr ""

#: ../../doc_src/language.rst:1540
msgid ""
"You can change the settings of fish by changing the values of certain "
"variables."
msgstr ""

#: ../../doc_src/language.rst:1544
msgid ""
"A list of directories in which to search for commands. This is a common "
"unix variable also used by other tools."
msgstr ""

#: ../../doc_src/language.rst:1548
msgid ""
"A list of directories in which the :doc:`cd <cmds/cd>` builtin looks for "
"a new directory."
msgstr ""

#: ../../doc_src/language.rst:1552
msgid ""
"Locale variables such as :envvar:`LANG`, :envvar:`LC_ALL`, "
":envvar:`LC_MESSAGES`, :envvar:`LC_NUMERIC` and :envvar:`LC_TIME` set the"
" language option for the shell and subprograms. See the section "
":ref:`Locale variables <variables-locale>` and :ref:`status language "
"<status-language>` for more information."
msgstr ""

#: ../../doc_src/language.rst:1557
msgid ""
"A number of variable starting with the prefixes ``fish_color`` and "
"``fish_pager_color``. See :ref:`Variables for changing highlighting "
"colors <variables-color>` for more information."
msgstr ""

#: ../../doc_src/language.rst:1561
msgid ""
"If this is set to 0, fish will not output 24-bit RGB true-color sequences"
" but the nearest color on the 256 color palette (or the 16 color palette,"
" if :envvar:`fish_term256` is 0). See also :doc:`set_color "
"<cmds/set_color>`. The default is 1 but for historical reasons, fish "
"defaults to behaving as if it was 0 on some terminals that are known to "
"not support true-color sequences."
msgstr ""

#: ../../doc_src/language.rst:1567
msgid ""
"If this is set to 0 and :envvar:`fish_term24bit` is 0, translate RGB "
"colors down to the 16 color palette. Also, if this is set to 0, "
":doc:`set_color <cmds/set_color>` commands such as ``set_color ff0000 "
"red`` will prefer the named color."
msgstr ""

#: ../../doc_src/language.rst:1572
msgid ""
"controls the computed width of ambiguous-width characters. This should be"
" set to 1 if your terminal renders these characters as single-width "
"(typical), or 2 if double-width."
msgstr ""

#: ../../doc_src/language.rst:1576
msgid ""
"controls whether fish assumes emoji render as 2 cells or 1 cell wide. "
"This is necessary because the correct value changed from 1 to 2 in "
"Unicode 9, and some terminals may not be aware. Set this if you see "
"graphical glitching related to emoji (or other \"special\" characters). "
"It should usually be auto-detected."
msgstr ""

#: ../../doc_src/language.rst:1580
msgid ""
"controls if :ref:`autosuggestions` are enabled. Set it to 0 to disable, "
"anything else to enable. By default they are on."
msgstr ""

#: ../../doc_src/language.rst:1584
msgid ""
"If this is set to 1, fish will redraw prompts with a ``--final-"
"rendering`` argument before running a commandline, allowing you to change"
" it before pushing it to the scrollback. This enables :ref:`transient "
"prompts <transient-prompt>`."
msgstr ""

#: ../../doc_src/language.rst:1588
msgid ""
"determines whether fish should try to repaint the commandline when the "
"terminal resizes. In terminals that reflow text this should be disabled. "
"Set it to 1 to enable, anything else to disable."
msgstr ""

#: ../../doc_src/language.rst:1592
msgid ""
"the name of the function that sets up the keyboard shortcuts for the :ref"
":`command-line editor <editor>`."
msgstr ""

#: ../../doc_src/language.rst:1596
msgid ""
"sets how long fish waits for another key after seeing an escape, to "
"distinguish pressing the escape key from the start of an escape sequence."
" The default is 30ms. Increasing it increases the latency but allows "
"pressing escape instead of alt for alt+character bindings. For more "
"information, see :ref:`the chapter in the bind documentation <cmd-bind-"
"escape>`."
msgstr ""

#: ../../doc_src/language.rst:1600
msgid ""
"sets how long fish waits for another key after seeing a key that is part "
"of a longer sequence, to disambiguate. For instance if you had bound "
"``\\cx\\ce`` to open an editor, fish would wait for this long in "
"milliseconds to see a ctrl-e after a ctrl-x. If the time elapses, it will"
" handle it as a ctrl-x (by default this would copy the current "
"commandline to the clipboard). See also :ref:`Key sequences <interactive-"
"key-sequences>`."
msgstr ""

#: ../../doc_src/language.rst:1604
msgid ""
"determines where fish looks for completion. When trying to complete for a"
" command, fish looks for files in the directories in this variable."
msgstr ""

#: ../../doc_src/language.rst:1608
msgid ""
"controls whether the selection is inclusive or exclusive of the character"
" under the cursor (see :ref:`Copy and Paste <killring>`)."
msgstr ""

#: ../../doc_src/language.rst:1612
msgid ""
"determines where fish looks for functions. When fish :ref:`autoloads "
"<syntax-function-autoloading>` a function, it will look for files in "
"these directories."
msgstr ""

#: ../../doc_src/language.rst:1616
msgid ""
"the greeting message printed on startup. This is printed by a function of"
" the same name that can be overridden for more complicated changes (see "
":doc:`funced <cmds/funced>`)"
msgstr ""

#: ../../doc_src/language.rst:1620
msgid ""
"the current history session name. If set, all subsequent commands within "
"an interactive fish session will be logged to a separate file identified "
"by the value of the variable. If unset, the default session name \"fish\""
" is used. If set to an empty string, history is not saved to disk (but is"
" still available within the interactive session)."
msgstr ""

#: ../../doc_src/language.rst:1628
msgid ""
"if set and not empty, will cause fish to print commands before they "
"execute, similar to ``set -x`` in bash. The trace is printed to the path "
"given by the `--debug-output` option to fish or the "
":envvar:`FISH_DEBUG_OUTPUT` variable. It goes to stderr by default. Set "
"it to ``all`` to also trace execution of key bindings, event handlers as "
"well as prompt and title functions."
msgstr ""

#: ../../doc_src/language.rst:1635
msgid ""
"Controls which debug categories :command:`fish` enables for output, "
"analogous to the ``--debug`` option."
msgstr ""

#: ../../doc_src/language.rst:1639
msgid "Specifies a file to direct debug output to."
msgstr ""

#: ../../doc_src/language.rst:1643
msgid ""
"a list of directories that are prepended to :envvar:`PATH`. This can be a"
" universal variable."
msgstr ""

#: ../../doc_src/language.rst:1647
msgid ""
"the current file creation mask. The preferred way to change the umask "
"variable is through the :doc:`umask <cmds/umask>` function. An attempt to"
" set umask to an invalid value will always fail."
msgstr ""

#: ../../doc_src/language.rst:1651
msgid ""
"your preferred web browser. If this variable is set, fish will use the "
"specified browser instead of the system default browser to display the "
"fish documentation."
msgstr ""

#: ../../doc_src/language.rst:1653
msgid ""
"Fish also provides additional information through the values of certain "
"environment variables. Most of these variables are read-only and their "
"value can't be changed with ``set``."
msgstr ""

#: ../../doc_src/language.rst:1657
msgid ""
"the name of the currently running command (though this is deprecated, and"
" the use of ``status current-command`` is preferred)."
msgstr ""

#: ../../doc_src/language.rst:1661
msgid ""
"a list of arguments to the shell or function. ``argv`` is only defined "
"when inside a function call, or if fish was invoked with a list of "
"arguments, like ``fish myscript.fish foo bar``. This variable can be "
"changed."
msgstr ""

#: ../../doc_src/language.rst:1665
msgid ""
":doc:`argparse <cmds/argparse>` sets this to the list of successfully "
"parsed options, including option-arguments. This variable can be changed."
msgstr ""

#: ../../doc_src/language.rst:1669
msgid "the runtime of the last command in milliseconds."
msgstr ""

#: ../../doc_src/language.rst:1673
msgid ""
"the current size of the terminal in height and width. These values are "
"only used by fish if the operating system does not report the size of the"
" terminal. Both variables must be set in that case otherwise a default of"
" 80x24 will be used. They are updated when the window size changes."
msgstr ""

#: ../../doc_src/language.rst:1677
msgid ""
"the signal that terminated the last foreground job, or 0 if the job "
"exited normally."
msgstr ""

#: ../../doc_src/language.rst:1681
msgid "a list of entries in fish's :ref:`kill ring <killring>` of cut text."
msgstr ""

#: ../../doc_src/language.rst:1685
msgid ""
"how many bytes fish will process with :doc:`read <cmds/read>` or in a "
":ref:`command substitution <expand-command-substitution>`."
msgstr ""

#: ../../doc_src/language.rst:1689
msgid "the process ID (PID) of the shell."
msgstr ""

#: ../../doc_src/language.rst:1693
msgid ""
"a read-only variable; set to ``light`` or ``dark`` when the terminal uses"
" a light or dark color theme respectively; set to ``unknown`` if the "
"terminal does not :ref:`report its colors <term-compat-query-background-"
"color>`. Like :ref:`status terminal <status-terminal>`, this is only "
"populated once the first interactive prompt is shown. This is used in an "
":ref:`--on-variable event handler <event>` to update :ref:`syntax "
"highlighting <syntax-highlighting>` variables whenever the terminal's "
"color theme changes. See :ref:`here <fish-config-theme-files>` for how to"
" specify ``light`` and ``dark`` variants in your theme."
msgstr ""

#: ../../doc_src/language.rst:1702
msgid "a list containing the last commands that were entered."
msgstr ""

#: ../../doc_src/language.rst:1706
msgid "the user's home directory. This variable can be changed."
msgstr ""

#: ../../doc_src/language.rst:1710
msgid "the machine's hostname."
msgstr ""

#: ../../doc_src/language.rst:1714
msgid ""
"the internal field separator that is used for word splitting with the "
":doc:`read <cmds/read>` builtin. Setting this to the empty string will "
"also disable line splitting in :ref:`command substitution <expand-"
"command-substitution>`. This variable can be changed."
msgstr ""

#: ../../doc_src/language.rst:1718
msgid "the process ID (PID) of the last background process."
msgstr ""

#: ../../doc_src/language.rst:1722
msgid "the current working directory."
msgstr ""

#: ../../doc_src/language.rst:1726
msgid ""
"a list of exit statuses of all processes that made up the last executed "
"pipe. See :ref:`exit status <variables-status>`."
msgstr ""

#: ../../doc_src/language.rst:1730
msgid ""
"the level of nesting of shells. Fish increments this in interactive "
"shells, otherwise it only passes it along."
msgstr ""

#: ../../doc_src/language.rst:1734
msgid ""
"the :ref:`exit status <variables-status>` of the last foreground job to "
"exit. If the job was terminated through a signal, the exit status will be"
" 128 plus the signal number."
msgstr ""

#: ../../doc_src/language.rst:1738
msgid ""
"the \"generation\" count of ``$status``. This will be incremented only "
"when the previous command produced an explicit status. (For example, "
"background jobs will not increment this)."
msgstr ""

#: ../../doc_src/language.rst:1742
msgid "the current username. This variable can be changed."
msgstr ""

#: ../../doc_src/language.rst:1746
msgid ""
"the current effective user id, set by fish at startup. This variable can "
"be changed."
msgstr ""

#: ../../doc_src/language.rst:1750
msgid ""
"the version of the currently running fish (also available as "
"``FISH_VERSION`` for backward compatibility)."
msgstr ""

#: ../../doc_src/language.rst:1752
msgid ""
"As a convention, an uppercase name is usually used for exported "
"variables, while lowercase variables are not exported. (``CMD_DURATION`` "
"is an exception for historical reasons). This rule is not enforced by "
"fish, but it is good coding practice to use casing to distinguish between"
" exported and unexported variables."
msgstr ""

#: ../../doc_src/language.rst:1754
msgid ""
"Fish also uses some variables internally, their name usually starting "
"with ``__fish``. These are internal and should not typically be modified "
"directly."
msgstr ""

#: ../../doc_src/language.rst:1759
msgid "The status variable"
msgstr ""

#: ../../doc_src/language.rst:1761
msgid ""
"Whenever a process exits, an exit status is returned to the program that "
"started it (usually the shell). This exit status is an integer number, "
"which tells the calling application how the execution of the command "
"went. In general, a zero exit status means that the command executed "
"without problem, but a non-zero exit status means there was some form of "
"problem."
msgstr ""

#: ../../doc_src/language.rst:1763
msgid ""
"Fish stores the exit status of the last process in the last job to exit "
"in the ``status`` variable."
msgstr ""

#: ../../doc_src/language.rst:1765
msgid ""
"If fish encounters a problem while executing a command, the status "
"variable may also be set to a specific value:"
msgstr ""

#: ../../doc_src/language.rst:1767
msgid ""
"0 is generally the exit status of commands if they successfully performed"
" the requested operation."
msgstr ""

#: ../../doc_src/language.rst:1769
msgid ""
"1 is generally the exit status of commands if they failed to perform the "
"requested operation."
msgstr ""

#: ../../doc_src/language.rst:1771
msgid ""
"121 is generally the exit status of commands if they were supplied with "
"invalid arguments."
msgstr ""

#: ../../doc_src/language.rst:1773
msgid ""
"123 means that the command was not executed because the command name "
"contained invalid characters."
msgstr ""

#: ../../doc_src/language.rst:1775
msgid ""
"124 means that the command was not executed because none of the wildcards"
" in the command produced any matches."
msgstr ""

#: ../../doc_src/language.rst:1777
msgid ""
"125 means that while an executable with the specified name was located, "
"the operating system could not actually execute the command."
msgstr ""

#: ../../doc_src/language.rst:1779
msgid ""
"126 means that while a file with the specified name was located, it was "
"not executable."
msgstr ""

#: ../../doc_src/language.rst:1781
msgid ""
"127 means that no function, builtin or command with the given name could "
"be located."
msgstr ""

#: ../../doc_src/language.rst:1783
msgid ""
"If a process exits through a signal, the exit status will be 128 plus the"
" number of the signal."
msgstr ""

#: ../../doc_src/language.rst:1785
msgid ""
"The status can be negated with :doc:`not <cmds/not>` (or ``!``), which is"
" useful in a :ref:`condition <syntax-conditional>`. This turns a status "
"of 0 into 1 and any non-zero status into 0."
msgstr ""

#: ../../doc_src/language.rst:1787
msgid ""
"There is also ``$pipestatus``, which is a list of all ``status`` values "
"of processes in a pipe. One difference is that :doc:`not <cmds/not>` "
"applies to ``$status``, but not ``$pipestatus``, because it loses "
"information."
msgstr ""

#: ../../doc_src/language.rst:1794
msgid ""
"Here ``$status`` reflects the status of ``grep``, which returns 0 if it "
"found something, negated with ``not`` (so 1 if it found something, 0 "
"otherwise). ``$pipestatus`` reflects the status of ``cat`` (which returns"
" non-zero for example when it couldn't find the file) and ``grep``, "
"without the negation."
msgstr ""

#: ../../doc_src/language.rst:1796
msgid ""
"So if both ``cat`` and ``grep`` succeeded, ``$status`` would be 1 because"
" of the ``not``, and ``$pipestatus`` would be 0 and 0."
msgstr ""

#: ../../doc_src/language.rst:1798
msgid ""
"It's possible for the first command to fail while the second succeeds. "
"One common example is when the second program quits early."
msgstr ""

#: ../../doc_src/language.rst:1800
msgid "For example, if you have a pipeline like::"
msgstr ""

#: ../../doc_src/language.rst:1804
msgid ""
"This will tell ``cat`` to print two files, \"file1\" and \"file2\", one "
"after the other, and the ``head`` will then only print the first 50 "
"lines. In this case you might often see this constellation::"
msgstr ""

#: ../../doc_src/language.rst:1811
msgid ""
"Here, the \"141\" signifies that ``cat`` was killed by signal number 13 "
"(128 + 13 == 141) - a ``SIGPIPE``. You can also use "
":envvar:`fish_kill_signal` to see the signal number. This happens because"
" it was still working, and then ``head`` closed the pipe, so ``cat`` "
"received a signal that it didn't ignore and so it died."
msgstr ""

#: ../../doc_src/language.rst:1813
msgid ""
"Whether ``cat`` here will see a SIGPIPE depends on how long the file is "
"and how much it writes at once, so you might see a pipestatus of \"0 0\","
" depending on the implementation. This is a general unix issue and not "
"specific to fish. Some shells feature a \"pipefail\" feature that will "
"call a pipeline failed if one of the processes in it failed, and this is "
"a big problem with it."
msgstr ""

#: ../../doc_src/language.rst:1818
msgid "Locale Variables"
msgstr ""

#: ../../doc_src/language.rst:1820
msgid ""
"The \"locale\" of a program is its set of language and regional settings."
" In UNIX, these are made up of several categories. The categories used by"
" fish are:"
msgstr ""

#: ../../doc_src/language.rst:1825
msgid ""
"This is the typical environment variable for specifying a locale. A user "
"may set this variable to express the language they speak, their region, "
"and a character encoding. The encoding part is ignored, fish always "
"assumes UTF-8. The actual values are specific to their platform, except "
"for special values like ``C`` or ``POSIX``."
msgstr ""

#: ../../doc_src/language.rst:1829
msgid ""
"The value of ``LANG`` is used for each category unless the variable for "
"that category was set or ``LC_ALL`` is set. So typically you only need to"
" set LANG."
msgstr ""

#: ../../doc_src/language.rst:1831
msgid ""
"Example values are ``en_US.UTF-8`` for the American English or "
"``de_AT.UTF-8`` for Austrian German. Your operating system might have a "
"``locale`` command that you can call as ``locale -a`` to see a list of "
"defined locales."
msgstr ""

#: ../../doc_src/language.rst:1836
msgid ""
"This is treated like :envvar:`LC_MESSAGES` except that it can hold "
"multiple values, which allows to specify a priority list of languages for"
" translation. It's a :ref:`PATH variable <variables-path>`, like in `GNU "
"gettext <https://www.gnu.org/software/gettext/manual/html_node/The-"
"LANGUAGE-variable.html>`__."
msgstr ""

#: ../../doc_src/language.rst:1840
msgid ""
"Language identifiers without a region specified (e.g. ``zh``) result in "
"all available variants of this language being tried in arbitrary order. "
"In this example, we might first look for messages in the ``zh_CN`` "
"catalog, followed by ``zh_TW``, or the other way around. This is "
"different from GNU gettext, which uses a \"default\" variant of the "
"language instead. If you prefer a certain variant, specify it earlier in "
"the list, e.g. ``zh_TW:zh`` if your preferred language is ``zh_TW``, and "
"you prefer any other variants of ``zh`` over the English default. If "
"``zh_TW`` is the only variant of ``zh`` you want, specifying ``zh_TW`` in"
" the ``LANGUAGE`` variable will result in messages which are not "
"available in ``zh_TW`` being displayed in English."
msgstr ""

#: ../../doc_src/language.rst:1848
msgid "See also :doc:`builtin _ (underscore) <cmds/_>`."
msgstr ""

#: ../../doc_src/language.rst:1852
msgid ""
"Overrides the :envvar:`LANG` and all other ``LC_*`` variables. Please use"
" ``LC_ALL`` only as a temporary override."
msgstr ""

#: ../../doc_src/language.rst:1857
msgid ""
"Determines the language in which messages are displayed, see "
":doc:`builtin _ (underscore) <cmds/_>`."
msgstr ""

#: ../../doc_src/language.rst:1861
msgid "Sets the locale for :doc:`formatting numbers <cmds/printf>`."
msgstr ""

#: ../../doc_src/language.rst:1865
msgid ""
"Determines how date and time are displayed. Used in the :ref:`history "
"<history-show-time>` builtin."
msgstr ""

#: ../../doc_src/language.rst:1871
msgid "Builtin commands"
msgstr ""

#: ../../doc_src/language.rst:1873
msgid ""
"Fish includes a number of commands in the shell directly. We call these "
"\"builtins\". These include:"
msgstr ""

#: ../../doc_src/language.rst:1875
msgid ""
"Builtins that manipulate the shell state - :doc:`cd <cmds/cd>` changes "
"directory, :doc:`set <cmds/set>` sets variables"
msgstr ""

#: ../../doc_src/language.rst:1876
msgid ""
"Builtins for dealing with data, like :doc:`string <cmds/string>` for "
"strings and :doc:`math <cmds/math>` for numbers, :doc:`count "
"<cmds/count>` for counting lines or arguments, :doc:`path <cmds/path>` "
"for dealing with path"
msgstr ""

#: ../../doc_src/language.rst:1877
msgid ":doc:`status <cmds/status>` for asking about the shell's status"
msgstr ""

#: ../../doc_src/language.rst:1878
msgid ""
":doc:`printf <cmds/printf>` and :doc:`echo <cmds/echo>` for creating "
"output"
msgstr ""

#: ../../doc_src/language.rst:1879
msgid ":doc:`test <cmds/test>` for checking conditions"
msgstr ""

#: ../../doc_src/language.rst:1880
msgid ":doc:`argparse <cmds/argparse>` for parsing function arguments"
msgstr ""

#: ../../doc_src/language.rst:1881
msgid ""
":doc:`source <cmds/source>` to read a script in the current shell (so "
"changes to variables stay) and :doc:`eval <cmds/eval>` to execute a "
"string as script"
msgstr ""

#: ../../doc_src/language.rst:1882
msgid ""
":doc:`random <cmds/random>` to get random numbers or pick a random "
"element from a list"
msgstr ""

#: ../../doc_src/language.rst:1883
msgid ":doc:`read <cmds/read>` for reading from a pipe or the terminal"
msgstr ""

#: ../../doc_src/language.rst:1885
msgid "For a list of all builtins, use ``builtin -n``."
msgstr ""

#: ../../doc_src/language.rst:1887
msgid ""
"For a list of all builtins, functions and commands shipped with fish, see"
" the :doc:`list of commands <commands>`. The documentation is also "
"available by using the ``--help`` switch."
msgstr ""

#: ../../doc_src/language.rst:1890
msgid "Command lookup"
msgstr ""

#: ../../doc_src/language.rst:1892
msgid ""
"When fish is told to run something, it goes through multiple steps to "
"find it."
msgstr ""

#: ../../doc_src/language.rst:1894
msgid ""
"If it contains a ``/``, fish tries to execute the given file, from the "
"current directory on."
msgstr ""

#: ../../doc_src/language.rst:1896
msgid ""
"If it doesn't contain a ``/``, it could be a function, builtin, or "
"external command, and so fish goes through the full lookup."
msgstr ""

#: ../../doc_src/language.rst:1898
msgid "In order:"
msgstr ""

#: ../../doc_src/language.rst:1900
msgid "It tries to resolve it as a :ref:`function <syntax-function>`."
msgstr ""

#: ../../doc_src/language.rst:1902
msgid "If the function is already known, it uses that"
msgstr ""

#: ../../doc_src/language.rst:1903
msgid ""
"If there is a file of the name with a \".fish\" suffix in "
":envvar:`fish_function_path`, it :ref:`loads that <syntax-function-"
"autoloading>`. (If there is more than one file only the first is used)"
msgstr ""

#: ../../doc_src/language.rst:1904
msgid "If the function is now defined it uses that"
msgstr ""

#: ../../doc_src/language.rst:1906
msgid "It tries to resolve it as a :ref:`builtin <builtin-overview>`."
msgstr ""

#: ../../doc_src/language.rst:1907
msgid "It tries to find an executable file in :envvar:`PATH`."
msgstr ""

#: ../../doc_src/language.rst:1909
msgid "If it finds a file, it tells the kernel to run it."
msgstr ""

#: ../../doc_src/language.rst:1910
msgid ""
"If the kernel knows how to run the file (e.g. via a ``#!`` line - "
"``#!/bin/sh`` or ``#!/usr/bin/python``), it does it."
msgstr ""

#: ../../doc_src/language.rst:1911
msgid ""
"If the kernel reports that it couldn't run it because of a missing "
"interpreter, and the file passes a rudimentary check, fish tells "
"``/bin/sh`` to run it."
msgstr ""

#: ../../doc_src/language.rst:1913
msgid ""
"If none of these work, fish runs the function "
":doc:`fish_command_not_found <cmds/fish_command_not_found>` and sets "
":envvar:`status` to 127."
msgstr ""

#: ../../doc_src/language.rst:1915
msgid "You can use :doc:`type <cmds/type>` to see how fish resolved something::"
msgstr ""

#: ../../doc_src/language.rst:1924
msgid "Querying for user input"
msgstr ""

#: ../../doc_src/language.rst:1926
msgid ""
"Sometimes, you want to ask the user for input, for instance to confirm "
"something. This can be done with the :doc:`read <cmds/read>` builtin."
msgstr ""

#: ../../doc_src/language.rst:1928
msgid ""
"Let's make up an example. This function will :ref:`glob <expand-"
"wildcard>` the files in all the directories it gets as :ref:`arguments "
"<variables-argv>`, and :ref:`if <syntax-conditional>` there are "
":doc:`more than five <cmds/test>` it will ask the user if it is supposed "
"to show them, but only if it is connected to a terminal::"
msgstr ""

#: ../../doc_src/language.rst:1965
msgid ""
"If you run this as ``show_files /``, it will most likely ask you until "
"you press Y/y or N/n. If you run this as ``show_files / | cat``, it will "
"print the files without asking. If you run this as ``show_files .``, it "
"might print something without asking because there are fewer than five "
"files."
msgstr ""

#: ../../doc_src/language.rst:1968
msgid "Shell variable and function names"
msgstr ""

#: ../../doc_src/language.rst:1970
msgid ""
"The names given to variables and functions (so-called \"identifiers\") "
"have to follow certain rules:"
msgstr ""

#: ../../doc_src/language.rst:1972
msgid ""
"A variable name cannot be empty. It can contain only letters, digits, and"
" underscores. It may begin and end with any of those characters."
msgstr ""

#: ../../doc_src/language.rst:1974
msgid ""
"A function name cannot be empty. It may not begin with a hyphen (\"-\") "
"and may not contain a slash (\"/\"). All other characters, including a "
"space, are valid. A function name also can't be the same as a reserved "
"keyword or essential builtin like ``if`` or ``set``."
msgstr ""

#: ../../doc_src/language.rst:1976
msgid ""
"A bind mode name (e.g., ``bind -m abc ...``) must be a valid variable "
"name."
msgstr ""

#: ../../doc_src/language.rst:1978
msgid ""
"Other things have other restrictions. For instance what is allowed for "
"file names depends on your system, but at the very least they cannot "
"contain a \"/\" (because that is the path separator) or NULL byte "
"(because that is how UNIX ends strings)."
msgstr ""

#: ../../doc_src/language.rst:1983
msgid "Configuration files"
msgstr ""

#: ../../doc_src/language.rst:1985
msgid ""
"When fish is started, it reads and runs its configuration files. Where "
"these are depends on build configuration and environment variables."
msgstr ""

#: ../../doc_src/language.rst:1987
msgid ""
"The main file is ``~/.config/fish/config.fish`` (or more precisely "
"``$XDG_CONFIG_HOME/fish/config.fish``)."
msgstr ""

#: ../../doc_src/language.rst:1989
msgid "Configuration files are run in the following order:"
msgstr ""

#: ../../doc_src/language.rst:1991
msgid "Configuration snippets (named ``*.fish``) in the directories:"
msgstr ""

#: ../../doc_src/language.rst:1993
msgid "``$__fish_config_dir/conf.d`` (by default, ``~/.config/fish/conf.d/``)"
msgstr ""

#: ../../doc_src/language.rst:1994
msgid "``$__fish_sysconf_dir/conf.d`` (by default, ``/etc/fish/conf.d/``)"
msgstr ""

#: ../../doc_src/language.rst:1995
msgid "Directories for others to ship configuration snippets for their software:"
msgstr ""

#: ../../doc_src/language.rst:1997
msgid ""
"the directories under ``$__fish_user_data_dir`` (usually "
"``~/.local/share/fish``, controlled by the ``XDG_DATA_HOME`` environment "
"variable)"
msgstr ""

#: ../../doc_src/language.rst:1998
msgid ""
"a ``fish/vendor_conf.d`` directory in the directories listed in "
"``$XDG_DATA_DIRS`` (default ``/usr/share/fish/vendor_conf.d`` and "
"``/usr/local/share/fish/vendor_conf.d``)"
msgstr ""

#: ../../doc_src/language.rst:2000
msgid ""
"These directories are also accessible in ``$__fish_vendor_confdirs``. "
"Note that changing that in a running fish won't do anything as by that "
"point the directories have already been read."
msgstr ""

#: ../../doc_src/language.rst:2003
msgid ""
"If there are multiple files with the same name in these directories, only"
" the first will be executed. They are executed in order of their "
"filename, sorted (like globs) in a natural order (i.e. \"01\" sorts "
"before \"2\")."
msgstr ""

#: ../../doc_src/language.rst:2006
msgid ""
"System-wide configuration files, where administrators can include "
"initialization for all users on the system - similar to ``/etc/profile`` "
"for POSIX-style shells - in ``$__fish_sysconf_dir`` (usually "
"``/etc/fish/config.fish``)."
msgstr ""

#: ../../doc_src/language.rst:2007
msgid ""
"User configuration, usually in ``~/.config/fish/config.fish`` (controlled"
" by the ``XDG_CONFIG_HOME`` environment variable, and accessible as "
"``$__fish_config_dir``)."
msgstr ""

#: ../../doc_src/language.rst:2009
msgid ""
"``~/.config/fish/config.fish`` is sourced *after* the snippets. This is "
"so you can copy snippets and override some of their behavior."
msgstr ""

#: ../../doc_src/language.rst:2011
msgid ""
"These files are all executed on the startup of every shell. If you want "
"to run a command only on starting an interactive shell, use the exit "
"status of the command ``status --is-interactive`` to determine if the "
"shell is interactive. If you want to run a command only when using a "
"login shell, use ``status --is-login`` instead. This will speed up the "
"starting of non-interactive or non-login shells."
msgstr ""

#: ../../doc_src/language.rst:2013
msgid ""
"If you are developing another program, you may want to add configuration "
"for all users of fish on a system. This is discouraged; if not carefully "
"written, they may have side-effects or slow the startup of the shell. "
"Additionally, users of other shells won't benefit from the fish-specific "
"configuration. However, if they are required, you can install them to the"
" \"vendor\" configuration directory. As this path may vary from system to"
" system, ``pkg-config`` should be used to discover it: ``pkg-config "
"--variable confdir fish``."
msgstr ""

#: ../../doc_src/language.rst:2015
msgid ""
"For system integration, fish also ships a file called "
"``__fish_build_paths.fish``. This can be customized during build, for "
"instance because your system requires special paths to be used."
msgstr ""

#: ../../doc_src/language.rst:2020
msgid "Future feature flags"
msgstr ""

#: ../../doc_src/language.rst:2022
msgid ""
"Feature flags are how fish stages changes that might break scripts. "
"Breaking changes are introduced as opt-in, in a few releases they become "
"opt-out, and eventually the old behavior is removed."
msgstr ""

#: ../../doc_src/language.rst:2024
msgid "You can see the current list of features via ``status features``::"
msgstr ""

#: ../../doc_src/language.rst:2038
msgid "Here is what they mean:"
msgstr ""

#: ../../doc_src/language.rst:2040
msgid ""
"``stderr-nocaret`` was introduced in fish 3.0 and cannot be turned off "
"since fish 3.5. It can still be tested for compatibility, but a ``no-"
"stderr-nocaret`` value will be ignored. The flag made ``^`` an ordinary "
"character instead of denoting an stderr redirection. Use ``2>`` instead."
msgstr ""

#: ../../doc_src/language.rst:2041
msgid ""
"``qmark-noglob`` was also introduced in fish 3.0 (and made the default in"
" 4.0). It makes ``?`` an ordinary character instead of a single-character"
" glob. Use a ``*`` instead (which will match multiple characters) or find"
" other ways to match files like ``find``."
msgstr ""

#: ../../doc_src/language.rst:2042
msgid ""
"``regex-easyesc`` was introduced in 3.1 (and made the default in 3.5). It"
" makes it so the replacement expression in ``string replace -r`` does one"
" fewer round of escaping. Before, to escape a backslash you would have to"
" use ``string replace -ra '([ab])' '\\\\\\\\\\\\\\\\$1'``. After, just "
"``'\\\\\\\\$1'`` is enough. Check your ``string replace`` calls if you "
"use this anywhere."
msgstr ""

#: ../../doc_src/language.rst:2043
msgid ""
"``ampersand-nobg-in-token`` was introduced in fish 3.4 (and made the "
"default in 3.5). It makes it so a ``&`` is no longer interpreted as the "
"backgrounding operator in the middle of a token, so dealing with URLs "
"becomes easier. Either put spaces or a semicolon after the ``&``. This is"
" recommended formatting anyway, and ``fish_indent`` will have done it for"
" you already."
msgstr ""

#: ../../doc_src/language.rst:2044
#, python-format
msgid ""
"``remove-percent-self`` turns off the special ``%self`` expansion. It was"
" introduced in 4.0. To get fish's pid, you can use the :envvar:`fish_pid`"
" variable."
msgstr ""

#: ../../doc_src/language.rst:2045
msgid ""
"``test-require-arg`` removes :doc:`builtin test <cmds/test>`'s one-"
"argument form (``test \"string\"``. It was introduced in 4.0. To test if "
"a string is non-empty, use ``test -n \"string\"``. If disabled, any call "
"to ``test`` that would change sends a :ref:`debug message <debugging-"
"fish>` of category \"deprecated-test\", so starting fish with ``fish "
"--debug=deprecated-test`` can be used to find offending calls."
msgstr ""

#: ../../doc_src/language.rst:2046
msgid ""
"``mark-prompt`` makes fish report to the terminal the beginning and and "
"of both shell prompts and command output."
msgstr ""

#: ../../doc_src/language.rst:2047
msgid ""
"``ignore-terminfo`` was introduced in fish 4.1 and cannot be turned off "
"since fish 4.5. It can still be tested for compatibility, but a ``no-"
"ignore-terminfo`` value will be ignored. The flag disabled lookup of "
"$TERM in the terminfo database."
msgstr ""

#: ../../doc_src/language.rst:2048
msgid ""
"``query-term`` allows fish to query the terminal by writing escape "
"sequences and reading the terminal's response. This enables features such"
" as :ref:`scrolling <term-compat-cursor-position-report>`. If you use an "
"incompatible terminal, you can -- for the time being -- work around it by"
" running (once) ``set -Ua fish_features no-query-term``."
msgstr ""

#: ../../doc_src/language.rst:2051
msgid ""
"``omit-term-workarounds`` prevents fish from trying to work around "
"incompatible terminals."
msgstr ""

#: ../../doc_src/language.rst:2054
msgid ""
"These changes are introduced off by default. They can be enabled on a per"
" session basis::"
msgstr ""

#: ../../doc_src/language.rst:2059
msgid "or opted into globally for a user::"
msgstr ""

#: ../../doc_src/language.rst:2064
msgid ""
"Features will only be set on startup, so this variable will only take "
"effect if it is universal or exported."
msgstr ""

#: ../../doc_src/language.rst:2066
msgid ""
"You can also use the version as a group, so ``3.0`` is equivalent to "
"\"stderr-nocaret\" and \"qmark-noglob\". Instead of a version, the "
"special group ``all`` enables all features."
msgstr ""

#: ../../doc_src/language.rst:2068
msgid ""
"Prefixing a feature with ``no-`` turns it off instead. E.g. to reenable "
"the ``?`` single-character glob::"
msgstr ""

#: ../../doc_src/language.rst:2075
msgid "Event handlers"
msgstr ""

#: ../../doc_src/language.rst:2077
msgid ""
"When defining a new function in fish, it is possible to make it into an "
"event handler, i.e. a function that is automatically run when a specific "
"event takes place. Events that can trigger a handler currently are:"
msgstr ""

#: ../../doc_src/language.rst:2079
msgid "When a signal is delivered"
msgstr ""

#: ../../doc_src/language.rst:2080
msgid "When a job exits"
msgstr ""

#: ../../doc_src/language.rst:2081
msgid "When the value of a variable is updated"
msgstr ""

#: ../../doc_src/language.rst:2082
msgid "When the prompt is about to be shown"
msgstr ""

#: ../../doc_src/language.rst:2086
msgid "To specify a signal handler for the WINCH signal, write::"
msgstr ""

#: ../../doc_src/language.rst:2092
msgid "Fish already has the following named events for the ``--on-event`` switch:"
msgstr ""

#: ../../doc_src/language.rst:2094
msgid ""
"``fish_prompt`` is emitted whenever a new fish prompt is about to be "
"displayed."
msgstr ""

#: ../../doc_src/language.rst:2096
msgid ""
"``fish_preexec`` is emitted right before executing an interactive "
"command. The commandline is passed as the first parameter. Not emitted if"
" command is empty."
msgstr ""

#: ../../doc_src/language.rst:2098
msgid ""
"``fish_posterror`` is emitted right after executing a command with syntax"
" errors. The commandline is passed as the first parameter."
msgstr ""

#: ../../doc_src/language.rst:2100
msgid ""
"``fish_postexec`` is emitted right after executing an interactive "
"command. The commandline is passed as the first parameter. Not emitted if"
" command is empty."
msgstr ""

#: ../../doc_src/language.rst:2102
msgid "``fish_exit`` is emitted right before fish exits."
msgstr ""

#: ../../doc_src/language.rst:2104
msgid "``fish_cancel`` is emitted when a commandline is cleared."
msgstr ""

#: ../../doc_src/language.rst:2106
msgid "``fish_focus_in`` is emitted when fish's terminal gains focus."
msgstr ""

#: ../../doc_src/language.rst:2108
msgid "``fish_focus_out`` is emitted when fish's terminal loses focus."
msgstr ""

#: ../../doc_src/language.rst:2110
msgid ""
"Events can be fired with the :doc:`emit <cmds/emit>` command, and do not "
"have to be defined before. The names just need to match. For example::"
msgstr ""

#: ../../doc_src/language.rst:2123
msgid ""
"If there are multiple handlers for an event, they will all be run, but "
"the order might change between fish releases, so you should not rely on "
"it."
msgstr ""

#: ../../doc_src/language.rst:2125
msgid ""
"Please note that event handlers only become active when a function is "
"loaded, which means you need to otherwise :doc:`source <cmds/source>` or "
"execute a function instead of relying on :ref:`autoloading <syntax-"
"function-autoloading>`. One approach is to put it into your "
":ref:`configuration file <configuration>`."
msgstr ""

#: ../../doc_src/language.rst:2127
msgid ""
"For more information on how to define new event handlers, see the "
"documentation for the :doc:`function <cmds/function>` command."
msgstr ""

#: ../../doc_src/language.rst:2133
msgid "Debugging fish scripts"
msgstr ""

#: ../../doc_src/language.rst:2135
msgid ""
"Fish includes basic built-in debugging facilities that allow you to stop "
"execution of a script at an arbitrary point. When this happens you are "
"presented with an interactive prompt where you can execute any fish "
"command to inspect or change state (there are no debug commands as such)."
" For example, you can check or change the value of any variables using "
":doc:`printf <cmds/printf>` and :doc:`set <cmds/set>`. As another "
"example, you can run :doc:`status print-stack-trace <cmds/status>` to see"
" how the current breakpoint was reached. To resume normal execution of "
"the script, type :doc:`exit <cmds/exit>` or :kbd:`ctrl-d`."
msgstr ""

#: ../../doc_src/language.rst:2137
msgid ""
"To start a debug session insert the :doc:`builtin command "
"<cmds/breakpoint>` ``breakpoint`` at the point in a function or script "
"where you wish to gain control, then run the function or script. Also, "
"the default action of the ``TRAP`` signal is to call this builtin, "
"meaning a running script can be actively debugged by sending it the "
"``TRAP`` signal (``kill -s TRAP <PID>``). There is limited support for "
"interactively setting or modifying breakpoints from this debug prompt: it"
" is possible to insert new breakpoints in (or remove old ones from) other"
" functions by using the ``funced`` function to edit the definition of a "
"function, but it is not possible to add or remove a breakpoint from the "
"function/script currently loaded and being executed."
msgstr ""

#: ../../doc_src/language.rst:2139
msgid ""
"Another way to debug script issues is to set the :envvar:`fish_trace` "
"variable, e.g. ``fish_trace=1 fish_prompt`` to see which commands fish "
"executes when running the :doc:`fish_prompt <cmds/fish_prompt>` function."
msgstr ""

#: ../../doc_src/language.rst:2144
msgid "Profiling fish scripts"
msgstr ""

#: ../../doc_src/language.rst:2146
msgid ""
"If you specifically want to debug performance issues, :program:`fish` can"
" be run with the ``--profile /path/to/profile.log`` option to save a "
"profile to the specified path. This profile log includes a breakdown of "
"how long each step in the execution took."
msgstr ""

#: ../../doc_src/language.rst:2155
msgid ""
"This will show the time for each command itself in the first column, the "
"time for the command and every subcommand (like any commands inside of a "
":ref:`function <syntax-function>` or :ref:`command substitutions <expand-"
"command-substitution>`) in the second and the command itself in the "
"third, separated with tabs."
msgstr ""

#: ../../doc_src/language.rst:2157
msgid "The time is given in microseconds."
msgstr ""

#: ../../doc_src/language.rst:2159
msgid ""
"To see the slowest commands last, ``sort -nk2 /path/to/logfile`` is "
"useful."
msgstr ""

#: ../../doc_src/language.rst:2161
msgid ""
"For profiling fish's startup there is also ``--profile-startup "
"/path/to/logfile``."
msgstr ""

#: ../../doc_src/language.rst:2163
msgid "See :doc:`fish <cmds/fish>` for more information."
msgstr ""

