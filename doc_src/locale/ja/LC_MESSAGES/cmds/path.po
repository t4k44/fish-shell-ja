# SOME DESCRIPTIVE TITLE.
# Copyright (C) fish-shell developers
# This file is distributed under the same license as the fish-shell package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2026.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: fish-shell 4.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-03-01 03:45+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../doc_src/cmds/path.rst:2
msgid "path - manipulate and check paths"
msgstr ""

#: ../../doc_src/cmds/path.rst:5
msgid "Synopsis"
msgstr ""

#: ../../doc_src/cmds/path.rst:29
msgid "Description"
msgstr ""

#: ../../doc_src/cmds/path.rst:31
msgid "``path`` performs operations on paths."
msgstr ""

#: ../../doc_src/cmds/path.rst:33
msgid ""
"PATH arguments are taken from the command line unless standard input is "
"connected to a pipe or a file, in which case they are read from standard "
"input, one PATH per line. It is an error to supply PATH arguments on both"
" the command line and on standard input."
msgstr ""

#: ../../doc_src/cmds/path.rst:35
msgid ""
"Arguments starting with ``-`` are normally interpreted as switches; "
"``--`` causes the following arguments not to be treated as switches even "
"if they begin with ``-``. Switches and required arguments are recognized "
"only on the command line."
msgstr ""

#: ../../doc_src/cmds/path.rst:37
msgid ""
"When a path starts with ``-``, ``path filter`` and ``path normalize`` "
"will prepend ``./`` on output to avoid it being interpreted as an option "
"otherwise, so it's safe to pass path's output to other commands that can "
"handle relative paths."
msgstr ""

#: ../../doc_src/cmds/path.rst:39
msgid ""
"All subcommands accept a ``-q`` or ``--quiet`` switch, which suppresses "
"the usual output but exits with the documented status. In this case these"
" commands will quit early, without reading all of the available input."
msgstr ""

#: ../../doc_src/cmds/path.rst:41
msgid ""
"All subcommands also accept a ``-Z`` or ``--null-out`` switch, which "
"makes them print output separated with NUL instead of newlines. This is "
"for further processing, e.g. passing to another ``path``, or ``xargs "
"-0``. This is not recommended when the output goes to the terminal or a "
"command substitution."
msgstr ""

#: ../../doc_src/cmds/path.rst:43
msgid ""
"All subcommands also accept a ``-z`` or ``--null-in`` switch, which makes"
" them accept arguments from stdin separated with NULL-bytes. Since Unix "
"paths can't contain NULL, that makes it possible to handle all possible "
"paths and read input from e.g. ``find -print0``. If arguments are given "
"on the commandline this has no effect. This should mostly be unnecessary "
"since ``path`` automatically starts splitting on NULL if one appears in "
"the first PATH_MAX bytes, PATH_MAX being the operating system's maximum "
"length for a path plus a NULL byte."
msgstr ""

#: ../../doc_src/cmds/path.rst:45
msgid ""
"Some subcommands operate on the paths as strings and so work on "
"nonexistent paths, while others need to access the paths themselves and "
"so filter out nonexistent paths."
msgstr ""

#: ../../doc_src/cmds/path.rst:47
msgid "The following subcommands are available."
msgstr ""

#: ../../doc_src/cmds/path.rst:52
msgid "\"basename\" subcommand"
msgstr ""

#: ../../doc_src/cmds/path.rst:58
msgid ""
"``path basename`` returns the last path component of the given path, by "
"removing the directory prefix and removing trailing slashes. In other "
"words, it is the part that is not the dirname. For files you might call "
"it the \"filename\"."
msgstr ""

#: ../../doc_src/cmds/path.rst:60
msgid ""
"If the ``-E`` or ``---no-extension`` option is used and the base name "
"contained a period, the path is returned with the extension (or the last "
"extension) removed, i.e. the \"filename\" without an extension (akin to "
"calling ``path change-extension \"\" (path basename $path)``)."
msgstr ""

#: ../../doc_src/cmds/path.rst:62
msgid ""
"It returns 0 if there was a basename, i.e. if the path wasn't empty or "
"just slashes."
msgstr ""

#: ../../doc_src/cmds/path.rst:65 ../../doc_src/cmds/path.rst:98
#: ../../doc_src/cmds/path.rst:125 ../../doc_src/cmds/path.rst:188
#: ../../doc_src/cmds/path.rst:235 ../../doc_src/cmds/path.rst:262
#: ../../doc_src/cmds/path.rst:298 ../../doc_src/cmds/path.rst:332
#: ../../doc_src/cmds/path.rst:363 ../../doc_src/cmds/path.rst:408
msgid "Examples"
msgstr ""

#: ../../doc_src/cmds/path.rst:87
msgid "\"dirname\" subcommand"
msgstr ""

#: ../../doc_src/cmds/path.rst:93
msgid ""
"``path dirname`` returns the dirname for the given path. This is the part"
" before the last \"/\", discounting trailing slashes. In other words, it "
"is the part that is not the basename (discounting superfluous slashes)."
msgstr ""

#: ../../doc_src/cmds/path.rst:95
msgid ""
"It returns 0 if there was a dirname, i.e. if the path wasn't empty or "
"just slashes."
msgstr ""

#: ../../doc_src/cmds/path.rst:112
msgid "\"extension\" subcommand"
msgstr ""

#: ../../doc_src/cmds/path.rst:118
msgid ""
"``path extension`` returns the extension of the given path. This is the "
"part after (and including) the last \".\", unless that \".\" followed a "
"\"/\" or the basename is \".\" or \"..\", in which case there is no "
"extension and an empty line is printed."
msgstr ""

#: ../../doc_src/cmds/path.rst:120
msgid "If the filename ends in a \".\", only a \".\" is printed."
msgstr ""

#: ../../doc_src/cmds/path.rst:122
msgid "It returns 0 if there was an extension."
msgstr ""

#: ../../doc_src/cmds/path.rst:153
msgid "\"filter\" subcommand"
msgstr ""

#: ../../doc_src/cmds/path.rst:161
msgid ""
"``path filter`` returns all of the given paths that match the given "
"checks. In all cases, the paths need to exist, nonexistent paths are "
"always filtered."
msgstr ""

#: ../../doc_src/cmds/path.rst:163
msgid "The available filters are:"
msgstr ""

#: ../../doc_src/cmds/path.rst:165
msgid ""
"``-t`` or ``--type`` with the options: \"dir\", \"file\", \"link\", "
"\"block\", \"char\", \"fifo\" and \"socket\", in which case the path "
"needs to be a directory, file, link, block device, character device, "
"named pipe or socket, respectively."
msgstr ""

#: ../../doc_src/cmds/path.rst:166
msgid ""
"``-d``, ``-f`` and ``-l`` are short for ``--type=dir``, ``--type=file`` "
"and ``--type=link``, respectively. There are no shortcuts for the other "
"types."
msgstr ""

#: ../../doc_src/cmds/path.rst:168
msgid ""
"``-p`` or ``--perm`` with the options: \"read\", \"write\", and \"exec\","
" as well as \"suid\", \"sgid\", \"user\" (referring to the path owner) "
"and \"group\" (referring to the path's group), in which case the path "
"needs to have all of the given permissions for the current user."
msgstr ""

#: ../../doc_src/cmds/path.rst:169
msgid ""
"``-r``, ``-w`` and ``-x`` are short for ``--perm=read``, ``--perm=write``"
" and ``--perm=exec``, respectively. There are no shortcuts for the other "
"permissions."
msgstr ""

#: ../../doc_src/cmds/path.rst:171
msgid ""
"Note that the path needs to be *any* of the given types, but have *all* "
"of the given permissions. This is because having a path that is both "
"writable and executable makes sense, but having a path that is both a "
"directory and a file doesn't. Links will count as the type of the linked-"
"to file, so links to files count as files, links to directories count as "
"directories."
msgstr ""

#: ../../doc_src/cmds/path.rst:173
msgid ""
"The filter options can either be given as multiple options, or comma-"
"separated - ``path filter -t dir,file`` or ``path filter --type dir "
"--type file`` are equivalent."
msgstr ""

#: ../../doc_src/cmds/path.rst:175
msgid ""
"With ``--invert``, the meaning of the filtering is inverted - any path "
"that wouldn't pass (including by not existing) passes, and any path that "
"would pass fails."
msgstr ""

#: ../../doc_src/cmds/path.rst:177
msgid ""
"When a path starts with ``-``, ``path filter`` will prepend ``./`` to "
"avoid it being interpreted as an option otherwise."
msgstr ""

#: ../../doc_src/cmds/path.rst:179
msgid "It returns 0 if at least one path passed the filter."
msgstr ""

#: ../../doc_src/cmds/path.rst:181
msgid ""
"With ``--all``, return status 0 (true) if all paths pass the filter, and "
"status 1 (false) if any path fails. This is equivalent to ``not path "
"filter -v``. It produces no output, only a status."
msgstr ""

#: ../../doc_src/cmds/path.rst:183
msgid ""
"When ``--all`` combined with ``--invert``, it returns status 0 (true) if "
"all paths fail the filter and status 1 (false) if any path passes."
msgstr ""

#: ../../doc_src/cmds/path.rst:185
msgid ""
"``path is`` is shorthand for ``path filter -q``, i.e. just checking "
"without producing output, see :ref:`The is subcommand <cmd-path-is>`."
msgstr ""

#: ../../doc_src/cmds/path.rst:222
msgid "\"is\" subcommand"
msgstr ""

#: ../../doc_src/cmds/path.rst:230
msgid ""
"``path is`` is short for ``path filter -q``. It returns true if any of "
"the given files passes the filter, but does not produce any output."
msgstr ""

#: ../../doc_src/cmds/path.rst:232
msgid ""
"``--quiet`` can still be passed for compatibility but is redundant. The "
"options are the same as for ``path filter``."
msgstr ""

#: ../../doc_src/cmds/path.rst:247
msgid "\"mtime\" subcommand"
msgstr ""

#: ../../doc_src/cmds/path.rst:253
msgid ""
"``path mtime`` returns the last modification time (\"mtime\" in unix "
"jargon) of the given paths, in seconds since the unix epoch (the "
"beginning of the 1st of January 1970)."
msgstr ""

#: ../../doc_src/cmds/path.rst:255
msgid ""
"With ``--relative`` (or ``-R``), it prints the number of seconds since "
"the modification time. It only reads the current time once at start, so "
"in case multiple paths are given the times are all relative to the "
"*start* of ``path mtime -R`` running."
msgstr ""

#: ../../doc_src/cmds/path.rst:257
msgid ""
"If you want to know if a file is newer or older than another file, "
"consider using ``test -nt`` instead. See :doc:`the test documentation "
"<test>`."
msgstr ""

#: ../../doc_src/cmds/path.rst:259
msgid "It returns 0 if reading mtime for any path succeeded."
msgstr ""

#: ../../doc_src/cmds/path.rst:281
msgid "\"normalize\" subcommand"
msgstr ""

#: ../../doc_src/cmds/path.rst:287
msgid ""
"``path normalize`` returns the normalized versions of all paths. That "
"means it squashes duplicate \"/\", collapses \"../\" with earlier "
"components and removes \".\" components."
msgstr ""

#: ../../doc_src/cmds/path.rst:289
msgid ""
"Unlike ``realpath`` or ``path resolve``, it does not make the paths "
"absolute. It also does not resolve any symlinks. As such it can operate "
"on non-existent paths."
msgstr ""

#: ../../doc_src/cmds/path.rst:291
msgid ""
"Because it operates on paths as strings and doesn't resolve symlinks, it "
"works sort of like ``pwd -L`` and ``cd``. E.g. ``path normalize link/..``"
" will return ``.``, just like ``cd link; cd ..`` would return to the "
"current directory. For a physical view of the filesystem, see ``path "
"resolve``."
msgstr ""

#: ../../doc_src/cmds/path.rst:293
msgid ""
"Leading \"./\" components are usually removed. But when a path starts "
"with ``-``, ``path normalize`` will add it instead to avoid confusion "
"with options."
msgstr ""

#: ../../doc_src/cmds/path.rst:295
msgid ""
"It returns 0 if any normalization was done, i.e. any given path wasn't in"
" canonical form."
msgstr ""

#: ../../doc_src/cmds/path.rst:317
msgid "\"resolve\" subcommand"
msgstr ""

#: ../../doc_src/cmds/path.rst:323
msgid ""
"``path resolve`` returns the normalized, physical and absolute versions "
"of all paths. That means it resolves symlinks and does what ``path "
"normalize`` does: it squashes duplicate \"/\", collapses \"../\" with "
"earlier components and removes \".\" components. Then it turns that path "
"into the absolute path starting from the filesystem root \"/\"."
msgstr ""

#: ../../doc_src/cmds/path.rst:325
msgid ""
"It is similar to ``realpath``, as it creates the \"real\", canonical "
"version of the path. However, for paths that can't be resolved, e.g. if "
"they don't exist or form a symlink loop, it will resolve as far as it can"
" and normalize the rest."
msgstr ""

#: ../../doc_src/cmds/path.rst:327
msgid ""
"Because it resolves symlinks, it works sort of like ``pwd -P``. E.g. "
"``path resolve link/..`` will return the parent directory of what the "
"link points to, just like ``cd link; cd (pwd -P)/..`` would go to it. For"
" a logical view of the filesystem, see ``path normalize``."
msgstr ""

#: ../../doc_src/cmds/path.rst:329
msgid ""
"It returns 0 if any normalization or resolution was done, i.e. any given "
"path wasn't in canonical form."
msgstr ""

#: ../../doc_src/cmds/path.rst:347
msgid "\"change-extension\" subcommand"
msgstr ""

#: ../../doc_src/cmds/path.rst:354
msgid ""
"``path change-extension`` returns the given paths, with their extension "
"changed to the given new extension. The extension is the part after (and "
"including) the last \".\", unless that \".\" followed a \"/\" or the "
"basename is \".\" or \"..\", in which case there is no previous extension"
" and the new one is added."
msgstr ""

#: ../../doc_src/cmds/path.rst:356
msgid ""
"If the extension is empty, any previous extension is stripped, along with"
" the \".\". This is, of course, the inverse of ``path extension``."
msgstr ""

#: ../../doc_src/cmds/path.rst:358
msgid ""
"One leading dot on the extension is ignored, so \".mp3\" and \"mp3\" are "
"treated the same."
msgstr ""

#: ../../doc_src/cmds/path.rst:360
msgid "It returns 0 if it was given any paths."
msgstr ""

#: ../../doc_src/cmds/path.rst:386
msgid "\"sort\" subcommand"
msgstr ""

#: ../../doc_src/cmds/path.rst:395
msgid ""
"``path sort`` returns the given paths in sorted order. They are sorted in"
" the same order as globs - alphabetically, but with runs of numerical "
"digits compared numerically."
msgstr ""

#: ../../doc_src/cmds/path.rst:397
msgid "With ``--reverse`` or ``-r`` the sort is reversed."
msgstr ""

#: ../../doc_src/cmds/path.rst:399
msgid ""
"With ``--key=`` only the given part of the path is compared, e.g. "
"``--key=dirname`` causes only the dirname to be compared, "
"``--key=basename`` only the basename and ``--key=path`` causes the entire"
" path to be compared (this is the default)."
msgstr ""

#: ../../doc_src/cmds/path.rst:401
msgid ""
"With ``--unique`` or ``-u`` the sort is deduplicated, meaning only the "
"first of a run that have the same key is kept. So if you are sorting by "
"basename, then only the first of each basename is used."
msgstr ""

#: ../../doc_src/cmds/path.rst:403
msgid ""
"The sort used is stable, so sorting first by basename and then by dirname"
" works and causes the files to be grouped according to directory."
msgstr ""

#: ../../doc_src/cmds/path.rst:405
msgid "It currently returns 0 if it was given any paths."
msgstr ""

#: ../../doc_src/cmds/path.rst:425
msgid "Combining ``path``"
msgstr ""

#: ../../doc_src/cmds/path.rst:427
msgid "``path`` is meant to be easy to combine with itself, other tools and fish."
msgstr ""

#: ../../doc_src/cmds/path.rst:429
msgid "This is why"
msgstr ""

#: ../../doc_src/cmds/path.rst:431
msgid ""
"``path``'s output is automatically split by fish if it goes into a "
"command substitution, so just doing ``(path ...)`` handles all paths, "
"even those containing newlines, correctly"
msgstr ""

#: ../../doc_src/cmds/path.rst:432
msgid ""
"``path`` has ``--null-in`` to handle null-delimited input (typically "
"automatically detected!), and ``--null-out`` to pass on null-delimited "
"output"
msgstr ""

#: ../../doc_src/cmds/path.rst:434
msgid "Some examples of combining ``path``::"
msgstr ""

