# SOME DESCRIPTIVE TITLE.
# Copyright (C) fish-shell developers
# This file is distributed under the same license as the fish-shell package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2026.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: fish-shell 4.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-03-01 03:45+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../doc_src/cmds/string.rst:2
msgid "string - manipulate strings"
msgstr ""

#: ../../doc_src/cmds/string.rst:5
msgid "Synopsis"
msgstr ""

#: ../../doc_src/cmds/string.rst:40
msgid "Description"
msgstr ""

#: ../../doc_src/cmds/string.rst:42
msgid "``string`` performs operations on strings."
msgstr ""

#: ../../doc_src/cmds/string.rst:44
msgid ""
"*STRING* arguments are taken from the command line unless standard input "
"is connected to a pipe or a file, in which case they are read from "
"standard input, one *STRING* per line. It is an error to supply *STRING* "
"arguments on the command line and on standard input."
msgstr ""

#: ../../doc_src/cmds/string.rst:46
msgid ""
"Arguments beginning with ``-`` are normally interpreted as switches; "
"``--`` causes the following arguments not to be treated as switches even "
"if they begin with ``-``. Switches and required arguments are recognized "
"only on the command line."
msgstr ""

#: ../../doc_src/cmds/string.rst:48
msgid ""
"Most subcommands accept a **-q** or **--quiet** switch, which suppresses "
"the usual output but exits with the documented status. In this case these"
" commands will quit early, without reading all of the available input."
msgstr ""

#: ../../doc_src/cmds/string.rst:50
msgid "The following subcommands are available."
msgstr ""

#: ../../doc_src/cmds/string.rst:53
msgid "\"collect\" subcommand"
msgstr ""

#: ../../doc_src/cmds/string-collect.rst:3
msgid ""
"``string collect`` collects its input into a single output argument, "
"without splitting the output when used in a command substitution. This is"
" useful when trying to collect multiline output from another command into"
" a variable. Exit status: 0 if any output argument is non-empty, or 1 "
"otherwise."
msgstr ""

#: ../../doc_src/cmds/string-collect.rst:5
msgid ""
"A command like ``echo (cmd | string collect)`` is mostly equivalent to a "
"quoted command substitution (``echo \"$(cmd)\"``). The main difference is"
" that the former evaluates to zero or one elements whereas the quoted "
"command substitution always evaluates to one element due to string "
"interpolation."
msgstr ""

#: ../../doc_src/cmds/string-collect.rst:7
msgid ""
"If invoked with multiple arguments instead of input, ``string collect`` "
"preserves each argument separately, where the number of output arguments "
"is equal to the number of arguments given to ``string collect``."
msgstr ""

#: ../../doc_src/cmds/string-collect.rst:9
msgid ""
"Any trailing newlines on the input are trimmed, just as with "
"``\"$(cmd)\"`` substitution. Use **--no-trim-newlines** to disable this "
"behavior, which may be useful when running a command such as ``set "
"contents (cat filename | string collect -N)``."
msgstr ""

#: ../../doc_src/cmds/string-collect.rst:11
msgid ""
"With **--allow-empty**, ``string collect`` always prints one (empty) "
"argument. This can be used to prevent an argument from disappearing."
msgstr ""

#: ../../doc_src/cmds/string.rst:64 ../../doc_src/cmds/string.rst:82
#: ../../doc_src/cmds/string.rst:100 ../../doc_src/cmds/string.rst:118
#: ../../doc_src/cmds/string.rst:166 ../../doc_src/cmds/string.rst:190
#: ../../doc_src/cmds/string.rst:214 ../../doc_src/cmds/string.rst:247
#: ../../doc_src/cmds/string.rst:265 ../../doc_src/cmds/string.rst:283
msgid "Examples"
msgstr ""

#: ../../doc_src/cmds/string.rst:71
msgid "\"escape\" and \"unescape\" subcommands"
msgstr ""

#: ../../doc_src/cmds/string-escape.rst:3
msgid "``string escape`` escapes each *STRING* in one of several ways."
msgstr ""

#: ../../doc_src/cmds/string-escape.rst:5
msgid ""
"**--style=script** (default) alters the string such that it can be passed"
" back to ``eval`` to produce the original argument again. By default, all"
" special characters are escaped, and quotes are used to simplify the "
"output when possible. If **-n** or **--no-quoted** is given, the "
"simplifying quoted format is not used. Exit status: 0 if at least one "
"string was escaped, or 1 otherwise."
msgstr ""

#: ../../doc_src/cmds/string-escape.rst:7
msgid ""
"**--style=var** ensures the string can be used as a variable name by hex "
"encoding any non-alphanumeric characters. The string is first converted "
"to UTF-8 before being encoded."
msgstr ""

#: ../../doc_src/cmds/string-escape.rst:9
msgid ""
"**--style=url** ensures the string can be used as a URL by hex encoding "
"any character which is not legal in a URL. The string is first converted "
"to UTF-8 before being encoded."
msgstr ""

#: ../../doc_src/cmds/string-escape.rst:11
msgid ""
"**--style=regex** escapes an input string for literal matching within a "
"regex expression. The string is first converted to UTF-8 before being "
"encoded."
msgstr ""

#: ../../doc_src/cmds/string-escape.rst:13
msgid ""
"``string unescape`` performs the inverse of the ``string escape`` "
"command. If the string to be unescaped is not properly formatted it is "
"ignored. For example, doing ``string unescape --style=var (string escape "
"--style=var $str)`` will return the original string. There is no support "
"for unescaping **--style=regex**."
msgstr ""

#: ../../doc_src/cmds/string.rst:89
msgid "\"join\" and \"join0\" subcommands"
msgstr ""

#: ../../doc_src/cmds/string-join.rst:3
msgid ""
"Joins its *STRING* arguments into a single string separated by *SEP* (for"
" ``string join``) or by the zero byte (NUL) (for ``string join0``). Exit "
"status: 0 if at least one join was performed, or 1 otherwise."
msgstr ""

#: ../../doc_src/cmds/string-join.rst:7
msgid "**-n**, **--no-empty**"
msgstr ""

#: ../../doc_src/cmds/string-join.rst:8
msgid ""
"Exclude empty strings from consideration (e.g. ``string join -n + a b "
"\"\" c`` would expand to ``a+b+c`` not ``a+b++c``)."
msgstr ""

#: ../../doc_src/cmds/string-join.rst:10
msgid "**-q**, **--quiet**"
msgstr ""

#: ../../doc_src/cmds/string-join.rst:11
msgid "Do not print the strings, only set the exit status as described above."
msgstr ""

#: ../../doc_src/cmds/string-join.rst:13
msgid ""
"**WARNING**: Insert a  ``--`` before positional arguments to prevent them"
" from being interpreted as flags. Otherwise, any strings starting with "
"``-`` will be treated as flag arguments, meaning they will most likely "
"result in the command failing. This is also true if you specify a "
"variable which expands to such a string instead of a literal string. If "
"you don't need to append flag arguments at the end of the command, just "
"always use ``--`` to avoid unwelcome surprises."
msgstr ""

#: ../../doc_src/cmds/string-join.rst:20
msgid ""
"``string join0`` adds a trailing NUL. This is most useful in conjunction "
"with tools that accept NUL-delimited input, such as ``sort -z``."
msgstr ""

#: ../../doc_src/cmds/string-join.rst:22
msgid ""
"Because Unix uses NUL as the string terminator, passing the output of "
"``string join0`` as an *argument* to a command (via a :ref:`command "
"substitution <expand-command-substitution>`) won't actually work. Fish "
"will pass the correct bytes along, but the command won't be able to tell "
"where the argument ends. This is a limitation of Unix' argument passing."
msgstr ""

#: ../../doc_src/cmds/string.rst:107
msgid "\"length\" subcommand"
msgstr ""

#: ../../doc_src/cmds/string-length.rst:3
msgid ""
"``string length`` reports the length of each string argument in "
"characters. Exit status: 0 if at least one non-empty *STRING* was given, "
"or 1 otherwise."
msgstr ""

#: ../../doc_src/cmds/string-length.rst:5
msgid ""
"With **-V** or **--visible**, it uses the visible width of the arguments."
" That means it will discount escape sequences fish knows about, account "
"for $fish_emoji_width and $fish_ambiguous_width. It will also count each "
"line (separated by ``\\n``) on its own, and with a carriage return "
"(``\\r``) count only the widest stretch on a line. The intent is to "
"measure the number of columns the *STRING* would occupy in the current "
"terminal."
msgstr ""

#: ../../doc_src/cmds/string.rst:125
msgid "\"lower\" subcommand"
msgstr ""

#: ../../doc_src/cmds/string-lower.rst:3
msgid ""
"``string lower`` converts each string argument to lowercase. Exit status:"
" 0 if at least one string was converted to lowercase, else 1. This means "
"that in conjunction with the **-q** flag you can readily test whether a "
"string is already lowercase."
msgstr ""

#: ../../doc_src/cmds/string.rst:140
msgid "\"match\" subcommand"
msgstr ""

#: ../../doc_src/cmds/string-match.rst:3
msgid ""
"``string match`` tests each *STRING* against *PATTERN* and prints "
"matching substrings. Only the first match for each *STRING* is reported "
"unless **-a** or **--all** is given, in which case all matches are "
"reported."
msgstr ""

#: ../../doc_src/cmds/string-match.rst:5
msgid ""
"If you specify the **-e** or **--entire** then each matching string is "
"printed including any prefix or suffix not matched by the pattern "
"(equivalent to ``grep`` without the **-o** flag). You can, obviously, "
"achieve the same result by prepending and appending **\\*** or **.*** "
"depending on whether or not you have specified the **--regex** flag. The "
"**--entire** flag is a way to avoid having to complicate the pattern in "
"that fashion and make the intent of the ``string match`` clearer. Without"
" **--entire** and **--regex**, a *PATTERN* will need to match the entire "
"*STRING* before it will be reported."
msgstr ""

#: ../../doc_src/cmds/string-match.rst:7
msgid "Matching can be made case-insensitive with **--ignore-case** or **-i**."
msgstr ""

#: ../../doc_src/cmds/string-match.rst:9
msgid ""
"If **--groups-only** or **-g** is given, only the capturing groups will "
"be reported - meaning the full match will be skipped. This is "
"incompatible with **--entire** and **--invert**, and requires "
"**--regex**. It is useful as a simple cutting tool instead of ``string "
"replace``, so you can choose \"this part\" of a string."
msgstr ""

#: ../../doc_src/cmds/string-match.rst:11
msgid ""
"If **--index** or **-n** is given, each match is reported as a 1-based "
"start position and a length. By default, PATTERN is interpreted as a glob"
" pattern matched against each entire *STRING* argument. A glob pattern is"
" only considered a valid match if it matches the entire *STRING*."
msgstr ""

#: ../../doc_src/cmds/string-match.rst:13
msgid ""
"If **--regex** or **-r** is given, *PATTERN* is interpreted as a Perl-"
"compatible regular expression, which does not have to match the entire "
"*STRING*. For a regular expression containing capturing groups, multiple "
"items will be reported for each match, one for the entire match and one "
"for each capturing group. With this, only the matching part of the "
"*STRING* will be reported, unless **--entire** is given."
msgstr ""

#: ../../doc_src/cmds/string-match.rst:15
msgid ""
"When matching via regular expressions, ``string match`` automatically "
"sets variables for all named capturing groups (``(?<name>expression)``). "
"It will create a variable with the name of the group, in the default "
"scope, for each named capturing group, and set it to the value of the "
"capturing group in the first matched argument. If a named capture group "
"matched an empty string, the variable will be set to the empty string "
"(like ``set var \"\"``). If it did not match, the variable will be set to"
" nothing (like ``set var``).  When **--regex** is used with **--all**, "
"this behavior changes. Each named variable will contain a list of "
"matches, with the first match contained in the first element, the second "
"match in the second, and so on. If the group was empty or did not match, "
"the corresponding element will be an empty string."
msgstr ""

#: ../../doc_src/cmds/string-match.rst:17
msgid ""
"If **--invert** or **-v** is used the selected lines will be only those "
"which do not match the given glob pattern or regular expression."
msgstr ""

#: ../../doc_src/cmds/string-match.rst:19
msgid ""
"If **--max-matches MAX** or **-m MAX** is used, ``string`` will stop "
"checking for matches after MAX lines of input have matched. This can be "
"used as an \"early exit\" optimization when processing long inputs but "
"expecting a limited and fixed number of outputs that might be found "
"considerably before the input stream has been exhausted. If combined with"
" **--invert** or **-v**, considers only inverted matches."
msgstr ""

#: ../../doc_src/cmds/string-match.rst:21
msgid "Exit status: 0 if at least one match was found, or 1 otherwise."
msgstr ""

#: ../../doc_src/cmds/string-match.rst:4
msgid "Match Glob Examples"
msgstr ""

#: ../../doc_src/cmds/string-match.rst:40
msgid "Match Regex Examples"
msgstr ""

#: ../../doc_src/cmds/string.rst:155
msgid "\"pad\" subcommand"
msgstr ""

#: ../../doc_src/cmds/string-pad.rst:3
msgid ""
"``string pad`` extends each *STRING* to the given visible width by adding"
" *CHAR* to the left. That means the width of all visible characters added"
" together, excluding escape sequences and accounting for "
":envvar:`fish_emoji_width` and :envvar:`fish_ambiguous_width`. It is the "
"amount of columns in a terminal the *STRING* occupies."
msgstr ""

#: ../../doc_src/cmds/string-pad.rst:5 ../../doc_src/cmds/string-shorten.rst:5
msgid ""
"The escape sequences reflect what fish knows about, and how it computes "
"its output. Your terminal might support more escapes, or not support "
"escape sequences that fish knows about."
msgstr ""

#: ../../doc_src/cmds/string-pad.rst:7
msgid ""
"If **-C** or **--center** is given, add the padding to before and after "
"the string. If it is impossible to perfectly center the result (because "
"the required amount of padding is an odd number), extra padding will be "
"added to the left, unless **--right** is also given."
msgstr ""

#: ../../doc_src/cmds/string-pad.rst:9
msgid "If **-r** or **--right** is given, add the padding after a string."
msgstr ""

#: ../../doc_src/cmds/string-pad.rst:11
msgid "If **-c** or **--char** is given, pad with *CHAR* instead of whitespace."
msgstr ""

#: ../../doc_src/cmds/string-pad.rst:13
msgid ""
"The output is padded to the maximum width of all input strings. If **-w**"
" or **--width** is given, use at least that."
msgstr ""

#: ../../doc_src/cmds/string.rst:173 ../../doc_src/cmds/string.rst:197
msgid "See also"
msgstr ""

#: ../../doc_src/cmds/string-pad.rst:3 ../../doc_src/cmds/string-shorten.rst:5
#, python-format
msgid ""
"The :doc:`printf <printf>` command can do simple padding, for example "
"``printf %10s\\n`` works like ``string pad -w10``."
msgstr ""

#: ../../doc_src/cmds/string-pad.rst:5 ../../doc_src/cmds/string-shorten.rst:7
msgid ""
":doc:`string length <string-length>` with the ``--visible`` option can be"
" used to show what fish thinks the width is."
msgstr ""

#: ../../doc_src/cmds/string.rst:179
msgid "\"shorten\" subcommand"
msgstr ""

#: ../../doc_src/cmds/string-shorten.rst:3
msgid ""
"``string shorten`` truncates each *STRING* to the given visible width and"
" adds an ellipsis to indicate it. \"Visible width\" means the width of "
"all visible characters added together, excluding escape sequences and "
"accounting for :envvar:`fish_emoji_width` and "
":envvar:`fish_ambiguous_width`. It is the amount of columns in a terminal"
" the *STRING* occupies."
msgstr ""

#: ../../doc_src/cmds/string-shorten.rst:7
msgid ""
"If **-m** or **--max** is given, truncate at the given width. Otherwise, "
"the lowest non-zero width of all input strings is used. A max of 0 means "
"no shortening takes place, all STRINGs are printed as-is."
msgstr ""

#: ../../doc_src/cmds/string-shorten.rst:9
msgid ""
"If **-N** or **--no-newline** is given, only the first line (or last line"
" with **--left**) of each STRING is used, and an ellipsis is added if it "
"was multiline. This only works for STRINGs being given as arguments, "
"multiple lines given on stdin will be interpreted as separate STRINGs "
"instead."
msgstr ""

#: ../../doc_src/cmds/string-shorten.rst:11
msgid ""
"If **-c** or **--char** is given, add *CHAR* instead of an ellipsis. This"
" can also be empty or more than one character."
msgstr ""

#: ../../doc_src/cmds/string-shorten.rst:13
msgid ""
"If **-l** or **--left** is given, remove text from the left on instead, "
"so this prints the longest *suffix* of the string that fits. With **--no-"
"newline**, this will take from the last line instead of the first."
msgstr ""

#: ../../doc_src/cmds/string-shorten.rst:15
msgid ""
"If **-q** or **--quiet** is given, ``string shorten`` only runs for the "
"return value - if anything would be shortened, it returns 0, else 1."
msgstr ""

#: ../../doc_src/cmds/string-shorten.rst:17
msgid ""
"The default ellipsis is ``â€¦``. If fish thinks your system is incapable "
"because of your locale, it will use ``...`` instead."
msgstr ""

#: ../../doc_src/cmds/string-shorten.rst:19
msgid "The return value is 0 if any shortening occurred, 1 otherwise."
msgstr ""

#: ../../doc_src/cmds/string-shorten.rst:3
msgid ""
":doc:`string pad <string-pad>` does the inverse of this command, adding "
"padding to a specific width instead."
msgstr ""

#: ../../doc_src/cmds/string.rst:203
msgid "\"repeat\" subcommand"
msgstr ""

#: ../../doc_src/cmds/string-repeat.rst:3
msgid ""
"``string repeat`` repeats the *STRING* **-n** or **--count** times. The "
"**-m** or **--max** option will limit the number of outputted characters "
"(excluding the newline). This option can be used by itself or in "
"conjunction with **--count**. If both **--count** and **--max** are "
"present, max char will be outputted unless the final repeated string size"
" is less than max, in that case, the string will repeat until count has "
"been reached. Both **--count** and **--max** will accept a number greater"
" than or equal to zero, in the case of zero, nothing will be outputted. "
"The first argument is interpreted as *COUNT* if **--count** or **--max** "
"are not explicitly specified. If **-N** or **--no-newline** is given, the"
" output won't contain a newline character at the end. Exit status: 0 if "
"yielded string is not empty, 1 otherwise."
msgstr ""

#: ../../doc_src/cmds/string-repeat.rst:4
msgid "Repeat Examples"
msgstr ""

#: ../../doc_src/cmds/string.rst:221
msgid "\"replace\" subcommand"
msgstr ""

#: ../../doc_src/cmds/string-replace.rst:3
msgid ""
"``string replace`` is similar to ``string match`` but replaces non-"
"overlapping matching substrings with a replacement string and prints the "
"result. By default, *PATTERN* is treated as a literal substring to be "
"matched."
msgstr ""

#: ../../doc_src/cmds/string-replace.rst:5
#, python-brace-format
msgid ""
"If **-r** or **--regex** is given, *PATTERN* is interpreted as a Perl-"
"compatible regular expression, and *REPLACEMENT* can contain C-style "
"escape sequences like **\\t** as well as references to capturing groups "
"by number or name as *$n* or *${n}*."
msgstr ""

#: ../../doc_src/cmds/string-replace.rst:7
msgid ""
"If you specify the **-f** or **--filter** flag then each input string is "
"printed only if a replacement was done. This is useful where you would "
"otherwise use this idiom: ``a_cmd | string match pattern | string replace"
" pattern new_pattern``. You can instead just write ``a_cmd | string "
"replace --filter pattern new_pattern``."
msgstr ""

#: ../../doc_src/cmds/string-replace.rst:9
msgid ""
"If **--max-matches MAX** or **-m MAX** is used, ``string replace`` will "
"stop all processing after MAX lines of input have matched the specified "
"pattern. In the event of ``--filter`` or ``-f``, this means the output "
"will be MAX lines in length. This can be used as an \"early exit\" "
"optimization when processing long inputs but expecting a limited and "
"fixed number of outputs that might be found considerably before the input"
" stream has been exhausted."
msgstr ""

#: ../../doc_src/cmds/string-replace.rst:11
msgid "Exit status: 0 if at least one replacement was performed, or 1 otherwise."
msgstr ""

#: ../../doc_src/cmds/string-replace.rst:4
msgid "Replace Literal Examples"
msgstr ""

#: ../../doc_src/cmds/string-replace.rst:20
msgid "Replace Regex Examples"
msgstr ""

#: ../../doc_src/cmds/string.rst:236
msgid "\"split\" and \"split0\" subcommands"
msgstr ""

#: ../../doc_src/cmds/string-split.rst:3
msgid ""
"``string split`` splits each *STRING* on the separator *SEP*, which can "
"be an empty string. If **-m** or **--max** is specified, at most MAX "
"splits are done on each *STRING*. If **-r** or **--right** is given, "
"splitting is performed right-to-left. This is only useful in combination "
"with **-m** or **--max**. With **-n** or **--no-empty**, empty results "
"are excluded from consideration (e.g. ``hello\\n\\nworld`` would expand "
"to two strings and not three). Exit status: 0 if at least one split was "
"performed, or 1 otherwise."
msgstr ""

#: ../../doc_src/cmds/string-split.rst:5
msgid ""
"Use **-f** or **--fields** to print out specific fields. FIELDS is a "
"comma-separated string of field numbers and/or spans. Each field is one-"
"indexed, and will be printed on separate lines. If a given field does not"
" exist, then the command exits with status 1 and does not print anything,"
" unless **--allow-empty** is used."
msgstr ""

#: ../../doc_src/cmds/string-split.rst:7
msgid "See also the **--delimiter** option of the :doc:`read <read>` command."
msgstr ""

#: ../../doc_src/cmds/string-split.rst:9
msgid ""
"``string split0`` splits each *STRING* on the zero byte (NUL). Options "
"are the same as ``string split`` except that no separator is given."
msgstr ""

#: ../../doc_src/cmds/string-split.rst:11
msgid ""
"``split0`` has the important property that its output is not further "
"split when used in a command substitution, allowing for the command "
"substitution to produce elements containing newlines. This is most useful"
" when used with Unix tools that produce zero bytes, such as ``find "
"-print0`` or ``sort -z``. See split0 examples below."
msgstr ""

#: ../../doc_src/cmds/string-split.rst:13
msgid ""
"Be aware that commandline arguments cannot include NULs, so you likely "
"want to pass to ``string split0`` via a pipe, not a command substitution."
msgstr ""

#: ../../doc_src/cmds/string-split.rst:25
msgid "NUL Delimited Examples"
msgstr ""

#: ../../doc_src/cmds/string.rst:254
msgid "\"sub\" subcommand"
msgstr ""

#: ../../doc_src/cmds/string-sub.rst:3
msgid ""
"``string sub`` prints a substring of each string argument. The start/end "
"of the substring can be specified with **-s**/**-e** or "
"**--start**/**--end** followed by a 1-based index value. Positive index "
"values are relative to the start of the string and negative index values "
"are relative to the end of the string. The default start value is 1. The "
"length of the substring can be specified with **-l** or **--length**. If "
"the length or end is not specified, the substring continues to the end of"
" each STRING. Exit status: 0 if at least one substring operation was "
"performed, 1 otherwise. **--length** is mutually exclusive with "
"**--end**."
msgstr ""

#: ../../doc_src/cmds/string.rst:272
msgid "\"trim\" subcommand"
msgstr ""

#: ../../doc_src/cmds/string-trim.rst:3
msgid ""
"``string trim`` removes leading and trailing whitespace from each "
"*STRING*. If **-l** or **--left** is given, only leading whitespace is "
"removed. If **-r** or **--right** is given, only trailing whitespace is "
"trimmed."
msgstr ""

#: ../../doc_src/cmds/string-trim.rst:5
msgid ""
"The **-c** or **--chars** switch causes the set of characters in *CHARS* "
"to be removed instead of whitespace. This is a set of characters, not a "
"string - if you pass ``-c foo``, it will remove any \"f\" or \"o\", not "
"just \"foo\" as a whole."
msgstr ""

#: ../../doc_src/cmds/string-trim.rst:7
msgid "Exit status: 0 if at least one character was trimmed, or 1 otherwise."
msgstr ""

#: ../../doc_src/cmds/string.rst:290
msgid "\"upper\" subcommand"
msgstr ""

#: ../../doc_src/cmds/string-upper.rst:3
msgid ""
"``string upper`` converts each string argument to uppercase. Exit status:"
" 0 if at least one string was converted to uppercase, else 1. This means "
"that in conjunction with the **-q** flag you can readily test whether a "
"string is already uppercase."
msgstr ""

#: ../../doc_src/cmds/string.rst:305
msgid "Regular Expressions"
msgstr ""

#: ../../doc_src/cmds/string.rst:307
msgid ""
"Both the ``match`` and ``replace`` subcommand support regular expressions"
" when used with the **-r** or **--regex** option. The dialect is that of "
"PCRE2."
msgstr ""

#: ../../doc_src/cmds/string.rst:309
msgid ""
"In general, special characters are special by default, so ``a+`` matches "
"one or more \"a\"s, while ``a\\+`` matches an \"a\" and then a \"+\". "
"``(a+)`` matches one or more \"a\"s in a capturing group (``(?:XXXX)`` "
"denotes a non-capturing group). For the replacement parameter of "
"``replace``, ``$n`` refers to the n-th group of the match. In the match "
"parameter, ``\\n`` (e.g. ``\\1``) refers back to groups."
msgstr ""

#: ../../doc_src/cmds/string.rst:311
msgid "Some features include repetitions:"
msgstr ""

#: ../../doc_src/cmds/string.rst:313
msgid "``*`` refers to 0 or more repetitions of the previous expression"
msgstr ""

#: ../../doc_src/cmds/string.rst:314
msgid "``+`` 1 or more"
msgstr ""

#: ../../doc_src/cmds/string.rst:315
msgid "``?`` 0 or 1."
msgstr ""

#: ../../doc_src/cmds/string.rst:316
#, python-brace-format
msgid "``{n}`` to exactly n (where n is a number)"
msgstr ""

#: ../../doc_src/cmds/string.rst:317
#, python-brace-format
msgid "``{n,m}`` at least n, no more than m."
msgstr ""

#: ../../doc_src/cmds/string.rst:318
#, python-brace-format
msgid "``{n,}`` n or more"
msgstr ""

#: ../../doc_src/cmds/string.rst:320
msgid "Character classes, some of the more important:"
msgstr ""

#: ../../doc_src/cmds/string.rst:322
msgid "``.`` any character except newline"
msgstr ""

#: ../../doc_src/cmds/string.rst:323
msgid "``\\d`` a decimal digit and ``\\D``, not a decimal digit"
msgstr ""

#: ../../doc_src/cmds/string.rst:324
msgid "``\\s`` whitespace and ``\\S``, not whitespace"
msgstr ""

#: ../../doc_src/cmds/string.rst:325
msgid "``\\w`` a \"word\" character and ``\\W``, a \"non-word\" character"
msgstr ""

#: ../../doc_src/cmds/string.rst:326
msgid "``[...]`` (where \"...\" is some characters) is a character set"
msgstr ""

#: ../../doc_src/cmds/string.rst:327
msgid "``[^...]`` is the inverse of the given character set"
msgstr ""

#: ../../doc_src/cmds/string.rst:328
msgid "``[x-y]`` is the range of characters from x-y"
msgstr ""

#: ../../doc_src/cmds/string.rst:329
msgid "``[[:xxx:]]`` is a named character set"
msgstr ""

#: ../../doc_src/cmds/string.rst:330
msgid "``[[:^xxx:]]`` is the inverse of a named character set"
msgstr ""

#: ../../doc_src/cmds/string.rst:331
msgid "``[[:alnum:]]``  : \"alphanumeric\""
msgstr ""

#: ../../doc_src/cmds/string.rst:332
msgid "``[[:alpha:]]``  : \"alphabetic\""
msgstr ""

#: ../../doc_src/cmds/string.rst:333
msgid "``[[:ascii:]]``  : \"0-127\""
msgstr ""

#: ../../doc_src/cmds/string.rst:334
msgid "``[[:blank:]]``  : \"space or tab\""
msgstr ""

#: ../../doc_src/cmds/string.rst:335
msgid "``[[:cntrl:]]``  : \"control character\""
msgstr ""

#: ../../doc_src/cmds/string.rst:336
msgid "``[[:digit:]]``  : \"decimal digit\""
msgstr ""

#: ../../doc_src/cmds/string.rst:337
msgid "``[[:graph:]]``  : \"printing, excluding space\""
msgstr ""

#: ../../doc_src/cmds/string.rst:338
msgid "``[[:lower:]]``  : \"lower case letter\""
msgstr ""

#: ../../doc_src/cmds/string.rst:339
msgid "``[[:print:]]``  : \"printing, including space\""
msgstr ""

#: ../../doc_src/cmds/string.rst:340
msgid "``[[:punct:]]``  : \"printing, excluding alphanumeric\""
msgstr ""

#: ../../doc_src/cmds/string.rst:341
msgid "``[[:space:]]``  : \"white space\""
msgstr ""

#: ../../doc_src/cmds/string.rst:342
msgid "``[[:upper:]]``  : \"upper case letter\""
msgstr ""

#: ../../doc_src/cmds/string.rst:343
msgid "``[[:word:]]``   : \"same as \\w\""
msgstr ""

#: ../../doc_src/cmds/string.rst:344
msgid "``[[:xdigit:]]`` : \"hexadecimal digit\""
msgstr ""

#: ../../doc_src/cmds/string.rst:346
msgid "Groups:"
msgstr ""

#: ../../doc_src/cmds/string.rst:348
msgid "``(...)`` is a capturing group"
msgstr ""

#: ../../doc_src/cmds/string.rst:349
msgid "``(?:...)`` is a non-capturing group"
msgstr ""

#: ../../doc_src/cmds/string.rst:350
msgid ""
"``\\n`` is a backreference (where n is the number of the group, starting "
"with 1)"
msgstr ""

#: ../../doc_src/cmds/string.rst:351
msgid ""
"``$n`` is a reference from the replacement expression to a group in the "
"match expression."
msgstr ""

#: ../../doc_src/cmds/string.rst:353
msgid "And some other things:"
msgstr ""

#: ../../doc_src/cmds/string.rst:355
msgid "``\\b`` denotes a word boundary, ``\\B`` is not a word boundary."
msgstr ""

#: ../../doc_src/cmds/string.rst:356
msgid "``^`` is the start of the string or line, ``$`` the end."
msgstr ""

#: ../../doc_src/cmds/string.rst:357
msgid "``|`` is \"alternation\", i.e. the \"or\"."
msgstr ""

#: ../../doc_src/cmds/string.rst:360
msgid "Comparison to other tools"
msgstr ""

#: ../../doc_src/cmds/string.rst:362
msgid ""
"Most operations ``string`` supports can also be done by external tools. "
"Some of these include ``grep``, ``sed`` and ``cut``."
msgstr ""

#: ../../doc_src/cmds/string.rst:364
msgid ""
"If you are familiar with these, it is useful to know how ``string`` "
"differs from them."
msgstr ""

#: ../../doc_src/cmds/string.rst:366
msgid ""
"In contrast to these classics, ``string`` reads input either from stdin "
"or as arguments. ``string`` also does not deal with files, so it requires"
" redirections to be used with them."
msgstr ""

#: ../../doc_src/cmds/string.rst:368
msgid ""
"In contrast to ``grep``, ``string``'s ``match`` defaults to glob-mode, "
"while ``replace`` defaults to literal matching. If set to regex-mode, "
"they use PCRE regular expressions, which is comparable to ``grep``'s "
"``-P`` option. ``match`` defaults to printing just the match, which is "
"like ``grep`` with ``-o`` (use **--entire** to enable grep-like "
"behavior)."
msgstr ""

#: ../../doc_src/cmds/string.rst:370
msgid ""
"Like ``sed``'s ``s/old/new/`` command, ``string replace`` still prints "
"strings that don't match. ``sed``'s ``-n`` in combination with a ``/p`` "
"modifier or command is like ``string replace -f``."
msgstr ""

#: ../../doc_src/cmds/string.rst:372
msgid ""
"``string split somedelimiter`` is a replacement for ``tr somedelimiter "
"\\n``."
msgstr ""

